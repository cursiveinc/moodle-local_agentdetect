{"version":3,"file":"interaction.min.js","sources":["../src/interaction.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Interaction anomaly detection module.\n *\n * Monitors user interactions (mouse, keyboard, scroll) to detect\n * patterns typical of automated browsers versus human users.\n *\n * @module     local_agentdetect/interaction\n * @copyright  2024 Your Institution\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n/**\n * Configuration for interaction monitoring.\n *\n * @type {Object}\n */\nconst CONFIG = {\n    // Minimum data points before analysis.\n    minMouseMoves: 20,\n    minClicks: 3,\n    minKeystrokes: 10,\n\n    // Thresholds for anomaly detection.\n    perfectTimingVariance: 5, // ms - variance below this is suspicious.\n    minHumanReactionTime: 50, // ms - clicks faster than this are suspicious.\n    maxMouseSpeed: 10000, // px/ms - movements faster than this are suspicious.\n    centerClickTolerance: 5, // px - clicks within this of element center are suspicious.\n\n    // Sampling configuration.\n    maxStoredEvents: 500,\n    analysisInterval: 10000, // ms - how often to run analysis.\n};\n\n/**\n * Event storage for analysis.\n *\n * @type {Object}\n */\nconst eventStore = {\n    mouseMoves: [],\n    clicks: [],\n    keystrokes: [],\n    scrolls: [],\n    hovers: [],\n    focusChanges: [],\n    pointerEvents: [],\n    startTime: Date.now(),\n};\n\n/**\n * Context ID for sessionStorage scoping (set in startMonitoring).\n *\n * @type {number|null}\n */\nlet contextId = null;\n\n/**\n * Analysis results cache.\n *\n * @type {Object|null}\n */\nlet analysisCache = null;\n\n/**\n * Whether monitoring is active.\n *\n * @type {boolean}\n */\nlet isMonitoring = false;\n\n/**\n * Start monitoring user interactions.\n *\n * @param {Object} options Configuration options.\n * @param {number} options.contextId Context ID for sessionStorage scoping.\n * @returns {void}\n */\nexport const startMonitoring = (options = {}) => {\n    if (isMonitoring) {\n        return;\n    }\n\n    isMonitoring = true;\n    contextId = options.contextId || null;\n    eventStore.startTime = Date.now();\n\n    // Restore accumulated events from prior pages in this session.\n    loadFromSessionStorage();\n\n    // Mouse movement tracking.\n    document.addEventListener('mousemove', handleMouseMove, {passive: true});\n\n    // Click tracking (capture phase to get all clicks).\n    document.addEventListener('click', handleClick, {capture: true, passive: true});\n    document.addEventListener('mousedown', handleMouseDown, {capture: true, passive: true});\n    document.addEventListener('mouseup', handleMouseUp, {capture: true, passive: true});\n\n    // Hover tracking.\n    document.addEventListener('mouseover', handleMouseOver, {passive: true});\n    document.addEventListener('mouseout', handleMouseOut, {passive: true});\n\n    // Keyboard tracking.\n    document.addEventListener('keydown', handleKeyDown, {capture: true, passive: true});\n    document.addEventListener('keyup', handleKeyUp, {capture: true, passive: true});\n\n    // Scroll tracking.\n    document.addEventListener('scroll', handleScroll, {passive: true});\n    window.addEventListener('scroll', handleScroll, {passive: true});\n\n    // Focus tracking.\n    document.addEventListener('focusin', handleFocusIn, {passive: true});\n    document.addEventListener('focusout', handleFocusOut, {passive: true});\n\n    // Pointer event tracking (for CDP dispatch detection).\n    document.addEventListener('pointerdown', handlePointerDown, {capture: true, passive: true});\n    document.addEventListener('pointermove', handlePointerMove, {passive: true});\n};\n\n/**\n * Stop monitoring user interactions.\n *\n * @returns {void}\n */\nexport const stopMonitoring = () => {\n    if (!isMonitoring) {\n        return;\n    }\n\n    isMonitoring = false;\n\n    document.removeEventListener('mousemove', handleMouseMove);\n    document.removeEventListener('click', handleClick, {capture: true});\n    document.removeEventListener('mousedown', handleMouseDown, {capture: true});\n    document.removeEventListener('mouseup', handleMouseUp, {capture: true});\n    document.removeEventListener('mouseover', handleMouseOver);\n    document.removeEventListener('mouseout', handleMouseOut);\n    document.removeEventListener('keydown', handleKeyDown, {capture: true});\n    document.removeEventListener('keyup', handleKeyUp, {capture: true});\n    document.removeEventListener('scroll', handleScroll);\n    window.removeEventListener('scroll', handleScroll);\n    document.removeEventListener('focusin', handleFocusIn);\n    document.removeEventListener('focusout', handleFocusOut);\n    document.removeEventListener('pointerdown', handlePointerDown, {capture: true});\n    document.removeEventListener('pointermove', handlePointerMove);\n};\n\n/**\n * Handle mouse move events.\n *\n * @param {MouseEvent} e Mouse event.\n */\nconst handleMouseMove = (e) => {\n    const now = performance.now();\n    const lastMove = eventStore.mouseMoves[eventStore.mouseMoves.length - 1];\n\n    const moveData = {\n        x: e.clientX,\n        y: e.clientY,\n        timestamp: now,\n        deltaTime: lastMove ? now - lastMove.timestamp : 0,\n        deltaX: lastMove ? e.clientX - lastMove.x : 0,\n        deltaY: lastMove ? e.clientY - lastMove.y : 0,\n    };\n\n    // Calculate velocity.\n    if (moveData.deltaTime > 0) {\n        const distance = Math.sqrt(moveData.deltaX ** 2 + moveData.deltaY ** 2);\n        moveData.velocity = distance / moveData.deltaTime;\n    }\n\n    addToStore('mouseMoves', moveData);\n};\n\n/**\n * Handle click events.\n *\n * @param {MouseEvent} e Mouse event.\n */\nconst handleClick = (e) => {\n    const now = performance.now();\n    const target = e.target;\n    const rect = target.getBoundingClientRect();\n\n    // Calculate click position relative to element center.\n    const elementCenterX = rect.left + rect.width / 2;\n    const elementCenterY = rect.top + rect.height / 2;\n    const offsetFromCenter = Math.sqrt(\n        (e.clientX - elementCenterX) ** 2 +\n        (e.clientY - elementCenterY) ** 2\n    );\n\n    const clickData = {\n        x: e.clientX,\n        y: e.clientY,\n        timestamp: now,\n        target: {\n            tagName: target.tagName,\n            id: target.id,\n            className: target.className,\n            width: rect.width,\n            height: rect.height,\n        },\n        offsetFromCenter: offsetFromCenter,\n        hadPrecedingHover: checkPrecedingHover(target),\n        hadPrecedingMouseMove: checkPrecedingMouseMove(e.clientX, e.clientY),\n    };\n\n    addToStore('clicks', clickData);\n};\n\n/**\n * Handle mousedown events.\n */\nconst handleMouseDown = () => {\n    // Store for click duration analysis.\n    const lastClick = eventStore.clicks[eventStore.clicks.length - 1];\n    if (lastClick && !lastClick.mousedownTime) {\n        lastClick.mousedownTime = performance.now();\n    }\n};\n\n/**\n * Handle mouseup events.\n */\nconst handleMouseUp = () => {\n    // Calculate click duration.\n    const lastClick = eventStore.clicks[eventStore.clicks.length - 1];\n    if (lastClick && lastClick.mousedownTime) {\n        lastClick.clickDuration = performance.now() - lastClick.mousedownTime;\n    }\n};\n\n/**\n * Handle mouseover events.\n *\n * @param {MouseEvent} e Mouse event.\n */\nconst handleMouseOver = (e) => {\n    addToStore('hovers', {\n        target: e.target,\n        timestamp: performance.now(),\n        type: 'over',\n    });\n};\n\n/**\n * Handle mouseout events.\n *\n * @param {MouseEvent} e Mouse event.\n */\nconst handleMouseOut = (e) => {\n    addToStore('hovers', {\n        target: e.target,\n        timestamp: performance.now(),\n        type: 'out',\n    });\n};\n\n/**\n * Handle keydown events.\n *\n * @param {KeyboardEvent} e Keyboard event.\n */\nconst handleKeyDown = (e) => {\n    const now = performance.now();\n    const lastKeystroke = eventStore.keystrokes[eventStore.keystrokes.length - 1];\n\n    addToStore('keystrokes', {\n        key: e.key.length === 1 ? 'char' : e.key, // Don't store actual characters for privacy.\n        timestamp: now,\n        deltaTime: lastKeystroke ? now - lastKeystroke.timestamp : 0,\n        type: 'down',\n    });\n};\n\n/**\n * Handle keyup events.\n */\nconst handleKeyUp = () => {\n    // Find matching keydown to calculate hold duration.\n    const keydowns = eventStore.keystrokes.filter(\n        (k) => k.type === 'down' && !k.holdDuration\n    );\n    const matchingKeydown = keydowns[keydowns.length - 1];\n    if (matchingKeydown) {\n        matchingKeydown.holdDuration = performance.now() - matchingKeydown.timestamp;\n    }\n};\n\n/**\n * Handle scroll events.\n */\nconst handleScroll = () => {\n    const now = performance.now();\n    const lastScroll = eventStore.scrolls[eventStore.scrolls.length - 1];\n\n    addToStore('scrolls', {\n        scrollY: window.scrollY,\n        scrollX: window.scrollX,\n        timestamp: now,\n        deltaTime: lastScroll ? now - lastScroll.timestamp : 0,\n        deltaY: lastScroll ? window.scrollY - lastScroll.scrollY : 0,\n        deltaX: lastScroll ? window.scrollX - lastScroll.scrollX : 0,\n    });\n};\n\n/**\n * Handle focus in events.\n *\n * @param {FocusEvent} e Focus event.\n */\nconst handleFocusIn = (e) => {\n    addToStore('focusChanges', {\n        target: {\n            tagName: e.target.tagName,\n            id: e.target.id,\n            type: e.target.type,\n        },\n        timestamp: performance.now(),\n        type: 'in',\n    });\n};\n\n/**\n * Handle focus out events.\n *\n * @param {FocusEvent} e Focus event.\n */\nconst handleFocusOut = (e) => {\n    addToStore('focusChanges', {\n        target: {\n            tagName: e.target.tagName,\n            id: e.target.id,\n            type: e.target.type,\n        },\n        timestamp: performance.now(),\n        type: 'out',\n    });\n};\n\n/**\n * Handle pointerdown events for CDP dispatch detection.\n *\n * @param {PointerEvent} e Pointer event.\n */\nconst handlePointerDown = (e) => {\n    addToStore('pointerEvents', {\n        type: 'down',\n        x: e.clientX,\n        y: e.clientY,\n        timestamp: performance.now(),\n        pointerType: e.pointerType,\n    });\n};\n\n/**\n * Handle pointermove events (throttled).\n *\n * @param {PointerEvent} e Pointer event.\n */\nconst handlePointerMove = (e) => {\n    const now = performance.now();\n    const last = eventStore.pointerEvents[eventStore.pointerEvents.length - 1];\n    if (last && now - last.timestamp < 50) {\n        return; // Throttle to 20Hz.\n    }\n    addToStore('pointerEvents', {\n        type: 'move',\n        x: e.clientX,\n        y: e.clientY,\n        timestamp: now,\n        pointerType: e.pointerType,\n    });\n};\n\n/**\n * Add event to storage with size limiting.\n *\n * @param {string} storeName Name of the store.\n * @param {Object} data Event data.\n */\nconst addToStore = (storeName, data) => {\n    eventStore[storeName].push(data);\n\n    // Limit store size.\n    if (eventStore[storeName].length > CONFIG.maxStoredEvents) {\n        eventStore[storeName].shift();\n    }\n\n    // Invalidate cache.\n    analysisCache = null;\n};\n\n/**\n * Check if there was a hover event before this click.\n *\n * @param {Element} target Click target.\n * @returns {boolean} True if hover preceded click.\n */\nconst checkPrecedingHover = (target) => {\n    const recentHovers = eventStore.hovers.slice(-20);\n    return recentHovers.some((h) => h.target === target && h.type === 'over');\n};\n\n/**\n * Check if there was mouse movement leading to click position.\n *\n * @param {number} x Click X coordinate.\n * @param {number} y Click Y coordinate.\n * @returns {boolean} True if mouse movement preceded click.\n */\nconst checkPrecedingMouseMove = (x, y) => {\n    const recentMoves = eventStore.mouseMoves.slice(-10);\n    if (recentMoves.length === 0) {\n        return false;\n    }\n\n    // Check if any recent movement was near the click position.\n    return recentMoves.some((m) => {\n        const distance = Math.sqrt((m.x - x) ** 2 + (m.y - y) ** 2);\n        return distance < 50;\n    });\n};\n\n/**\n * Analyze collected interaction data for anomalies.\n *\n * @returns {Object} Analysis results with anomaly signals.\n */\nexport const analyze = () => {\n    if (analysisCache) {\n        return analysisCache;\n    }\n\n    const results = {\n        timestamp: Date.now(),\n        duration: Date.now() - eventStore.startTime,\n        eventCounts: {\n            mouseMoves: eventStore.mouseMoves.length,\n            clicks: eventStore.clicks.length,\n            keystrokes: eventStore.keystrokes.length,\n            scrolls: eventStore.scrolls.length,\n            hovers: eventStore.hovers.length,\n            focusChanges: eventStore.focusChanges.length,\n        },\n        anomalies: [],\n        score: 0,\n    };\n\n    // Run individual analyses.\n    results.anomalies.push(...analyzeMouseMovement());\n    results.anomalies.push(...analyzeClicks());\n    results.anomalies.push(...analyzeKeystrokes());\n    results.anomalies.push(...analyzeScrolling());\n    results.anomalies.push(...analyzeEventSequence());\n\n    // Comet agentic mode analyses.\n    results.anomalies.push(...analyzeActionBursts());\n    results.anomalies.push(...analyzeCDPClickPatterns());\n    results.anomalies.push(...analyzePointerEvents());\n\n    // Calculate overall score.\n    results.score = calculateInteractionScore(results.anomalies);\n\n    analysisCache = results;\n    return results;\n};\n\n/**\n * Analyze mouse movement patterns.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzeMouseMovement = () => {\n    const anomalies = [];\n    const moves = eventStore.mouseMoves;\n\n    if (moves.length < CONFIG.minMouseMoves) {\n        anomalies.push({\n            name: 'mouse.insufficient_data',\n            value: moves.length,\n            weight: 2,\n        });\n        return anomalies;\n    }\n\n    // Check for perfectly linear movements (no human does this).\n    const linearSegments = findLinearSegments(moves);\n    if (linearSegments > moves.length * 0.3) {\n        anomalies.push({\n            name: 'mouse.linear_movement',\n            value: linearSegments / moves.length,\n            weight: 7,\n        });\n    }\n\n    // Check for teleporting (instant position changes).\n    const teleports = moves.filter((m) => m.velocity > CONFIG.maxMouseSpeed);\n    if (teleports.length > 0) {\n        anomalies.push({\n            name: 'mouse.teleport',\n            value: teleports.length,\n            weight: 8,\n        });\n    }\n\n    // Check for no mouse movement at all (common in automated tests).\n    const duration = Date.now() - eventStore.startTime;\n    if (moves.length < duration / 5000) { // Less than 1 move per 5 seconds.\n        anomalies.push({\n            name: 'mouse.sparse_movement',\n            value: moves.length,\n            weight: 5,\n        });\n    }\n\n    // Check velocity variance (humans have high variance).\n    const velocities = moves.filter((m) => m.velocity).map((m) => m.velocity);\n    if (velocities.length > 5) {\n        const variance = calculateVariance(velocities);\n        if (variance < 0.1) {\n            anomalies.push({\n                name: 'mouse.constant_velocity',\n                value: variance,\n                weight: 6,\n            });\n        }\n    }\n\n    return anomalies;\n};\n\n/**\n * Find linear segments in mouse movement.\n *\n * @param {Array} moves Mouse move events.\n * @returns {number} Count of linear segments.\n */\nconst findLinearSegments = (moves) => {\n    let linearCount = 0;\n    const threshold = 0.99; // Angle consistency threshold.\n\n    for (let i = 2; i < moves.length; i++) {\n        const angle1 = Math.atan2(\n            moves[i - 1].y - moves[i - 2].y,\n            moves[i - 1].x - moves[i - 2].x\n        );\n        const angle2 = Math.atan2(\n            moves[i].y - moves[i - 1].y,\n            moves[i].x - moves[i - 1].x\n        );\n\n        if (Math.abs(Math.cos(angle1 - angle2)) > threshold) {\n            linearCount++;\n        }\n    }\n\n    return linearCount;\n};\n\n/**\n * Analyze click patterns.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzeClicks = () => {\n    const anomalies = [];\n    const clicks = eventStore.clicks;\n\n    if (clicks.length < CONFIG.minClicks) {\n        return anomalies;\n    }\n\n    // Check for clicks at exact element centers (agents click perfectly).\n    const centerClicks = clicks.filter(\n        (c) => c.offsetFromCenter < CONFIG.centerClickTolerance\n    );\n    if (centerClicks.length > clicks.length * 0.5) {\n        anomalies.push({\n            name: 'click.center_precision',\n            value: centerClicks.length / clicks.length,\n            weight: 10, // Increased - strong agent indicator.\n        });\n    }\n\n    // Ultra-precise center clicks (< 2px offset) -- strong agentic indicator.\n    // Agents target elements by reference, landing at exact computed center.\n    const ultraPreciseClicks = clicks.filter(\n        (c) => c.offsetFromCenter < 2\n    );\n    if (ultraPreciseClicks.length > clicks.length * 0.6 && clicks.length >= 3) {\n        anomalies.push({\n            name: 'comet.ultra_precise_center',\n            value: ultraPreciseClicks.length / clicks.length,\n            weight: 10,\n        });\n    }\n\n    // Check for clicks without preceding hover.\n    const noHoverClicks = clicks.filter((c) => !c.hadPrecedingHover);\n    if (noHoverClicks.length > clicks.length * 0.7) {\n        anomalies.push({\n            name: 'click.no_hover',\n            value: noHoverClicks.length / clicks.length,\n            weight: 6,\n        });\n    }\n\n    // Check for clicks without preceding mouse movement (teleport clicks).\n    const noMoveClicks = clicks.filter((c) => !c.hadPrecedingMouseMove);\n    if (noMoveClicks.length > clicks.length * 0.5) {\n        anomalies.push({\n            name: 'click.no_movement',\n            value: noMoveClicks.length / clicks.length,\n            weight: 9, // Increased - agents teleport to click targets.\n        });\n    }\n\n    // STRONG INDICATOR: Clicks with NO mouse data at all (pure teleport).\n    const totalMouseMoves = eventStore.mouseMoves.length;\n    if (clicks.length >= 3 && totalMouseMoves < clicks.length * 2) {\n        anomalies.push({\n            name: 'click.teleport_pattern',\n            value: totalMouseMoves / clicks.length,\n            weight: 10, // Very strong - humans move mouse much more than they click.\n        });\n    }\n\n    // Check for impossibly fast clicks (< 50ms reaction time).\n    const interClickTimes = [];\n    for (let i = 1; i < clicks.length; i++) {\n        interClickTimes.push(clicks[i].timestamp - clicks[i - 1].timestamp);\n    }\n    const fastClicks = interClickTimes.filter((t) => t < CONFIG.minHumanReactionTime);\n    if (fastClicks.length > 0) {\n        anomalies.push({\n            name: 'click.superhuman_speed',\n            value: fastClicks.length,\n            weight: 10, // Increased - definitive agent indicator.\n        });\n    }\n\n    // Check for perfectly regular click timing.\n    if (interClickTimes.length >= 3) {\n        const variance = calculateVariance(interClickTimes);\n        if (variance < CONFIG.perfectTimingVariance) {\n            anomalies.push({\n                name: 'click.perfect_timing',\n                value: variance,\n                weight: 8,\n            });\n        }\n    }\n\n    return anomalies;\n};\n\n/**\n * Analyze keystroke patterns.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzeKeystrokes = () => {\n    const anomalies = [];\n    const keystrokes = eventStore.keystrokes.filter((k) => k.type === 'down');\n\n    if (keystrokes.length < CONFIG.minKeystrokes) {\n        return anomalies;\n    }\n\n    // Check inter-key timing variance.\n    const interKeyTimes = keystrokes.slice(1).map((k) => k.deltaTime);\n    if (interKeyTimes.length >= 5) {\n        const variance = calculateVariance(interKeyTimes);\n        if (variance < CONFIG.perfectTimingVariance) {\n            anomalies.push({\n                name: 'keystroke.perfect_timing',\n                value: variance,\n                weight: 9,\n            });\n        }\n    }\n\n    // Comet-specific: check coefficient of variation for inter-key timing.\n    // Human typing has CV > 0.3; agent-dispatched keystrokes have CV < 0.1.\n    const keyMean = interKeyTimes.reduce((a, b) => a + b, 0) / interKeyTimes.length;\n    const keyStdDev = Math.sqrt(calculateVariance(interKeyTimes));\n    const keyCV = keyMean > 0 ? keyStdDev / keyMean : 0;\n\n    if (keyCV < 0.1 && interKeyTimes.length >= 10) {\n        anomalies.push({\n            name: 'comet.uniform_keystroke_cadence',\n            value: keyCV,\n            weight: 9,\n        });\n    }\n\n    // Check for impossibly fast typing (< 30ms between keys is ~2000 WPM).\n    const fastKeys = interKeyTimes.filter((t) => t > 0 && t < 30);\n    if (fastKeys.length > interKeyTimes.length * 0.3) {\n        anomalies.push({\n            name: 'keystroke.superhuman_speed',\n            value: fastKeys.length / interKeyTimes.length,\n            weight: 9,\n        });\n    }\n\n    // Check key hold duration variance.\n    const holdDurations = keystrokes.filter((k) => k.holdDuration).map((k) => k.holdDuration);\n    if (holdDurations.length >= 5) {\n        const variance = calculateVariance(holdDurations);\n        if (variance < 1) {\n            anomalies.push({\n                name: 'keystroke.constant_hold',\n                value: variance,\n                weight: 7,\n            });\n        }\n\n        // Comet-specific: check hold duration coefficient of variation.\n        if (holdDurations.length >= 10) {\n            const holdMean = holdDurations.reduce((a, b) => a + b, 0) / holdDurations.length;\n            const holdStdDev = Math.sqrt(calculateVariance(holdDurations));\n            const holdCV = holdMean > 0 ? holdStdDev / holdMean : 0;\n\n            if (holdCV < 0.1) {\n                anomalies.push({\n                    name: 'comet.uniform_hold_duration',\n                    value: holdCV,\n                    weight: 8,\n                });\n            }\n        }\n    }\n\n    return anomalies;\n};\n\n/**\n * Analyze scrolling patterns.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzeScrolling = () => {\n    const anomalies = [];\n    const scrolls = eventStore.scrolls;\n\n    if (scrolls.length < 3) {\n        return anomalies;\n    }\n\n    // Check for instant scroll jumps (no smooth scrolling).\n    const instantScrolls = scrolls.filter((s) => s.deltaTime < 10 && Math.abs(s.deltaY) > 100);\n    if (instantScrolls.length > scrolls.length * 0.5) {\n        anomalies.push({\n            name: 'scroll.instant_jump',\n            value: instantScrolls.length / scrolls.length,\n            weight: 6,\n        });\n    }\n\n    // Check for perfectly regular scroll amounts.\n    const scrollAmounts = scrolls.map((s) => Math.abs(s.deltaY)).filter((v) => v > 0);\n    if (scrollAmounts.length >= 3) {\n        const variance = calculateVariance(scrollAmounts);\n        if (variance < 1) {\n            anomalies.push({\n                name: 'scroll.constant_amount',\n                value: variance,\n                weight: 5,\n            });\n        }\n    }\n\n    return anomalies;\n};\n\n/**\n * Analyze event sequence patterns.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzeEventSequence = () => {\n    const anomalies = [];\n\n    // Check for missing event sequences (e.g., click without mousedown).\n    // Automated tools sometimes skip intermediate events.\n\n    // Check ratio of hovers to clicks (humans hover a lot before clicking).\n    const hoverRatio = eventStore.hovers.length / Math.max(eventStore.clicks.length, 1);\n    if (hoverRatio < 2 && eventStore.clicks.length >= CONFIG.minClicks) {\n        anomalies.push({\n            name: 'sequence.low_hover_ratio',\n            value: hoverRatio,\n            weight: 5,\n        });\n    }\n\n    // Check for focus changes without preceding clicks or tabs.\n    // Direct focus (via JS) is common in automation.\n    const directFocus = eventStore.focusChanges.filter((f) => {\n        // Check if there was a recent click or keystroke.\n        const recentEvents = [\n            ...eventStore.clicks.slice(-5),\n            ...eventStore.keystrokes.slice(-5),\n        ];\n        const hasRecentInteraction = recentEvents.some(\n            (e) => Math.abs(e.timestamp - f.timestamp) < 100\n        );\n        return !hasRecentInteraction;\n    });\n\n    if (directFocus.length > eventStore.focusChanges.length * 0.5 &&\n        eventStore.focusChanges.length >= 3) {\n        anomalies.push({\n            name: 'sequence.direct_focus',\n            value: directFocus.length / eventStore.focusChanges.length,\n            weight: 6,\n        });\n    }\n\n    // Rapid sequential focus changes across different form fields.\n    // Agents navigate fields programmatically, producing near-instant focus changes.\n    const focusIns = eventStore.focusChanges.filter((f) => f.type === 'in');\n    if (focusIns.length >= 3) {\n        let rapidSequentialFocus = 0;\n        for (let j = 1; j < focusIns.length; j++) {\n            const gap = focusIns[j].timestamp - focusIns[j - 1].timestamp;\n            const differentTarget = focusIns[j].target.id !== focusIns[j - 1].target.id;\n            if (gap < 200 && differentTarget) {\n                rapidSequentialFocus++;\n            }\n        }\n        if (rapidSequentialFocus >= 2) {\n            anomalies.push({\n                name: 'comet.rapid_focus_sequence',\n                value: rapidSequentialFocus,\n                weight: 7,\n            });\n        }\n    }\n\n    return anomalies;\n};\n\n/**\n * Calculate variance of an array of numbers.\n *\n * @param {Array<number>} arr Array of numbers.\n * @returns {number} Variance.\n */\nconst calculateVariance = (arr) => {\n    if (arr.length < 2) {\n        return 0;\n    }\n    const mean = arr.reduce((a, b) => a + b, 0) / arr.length;\n    const squareDiffs = arr.map((value) => Math.pow(value - mean, 2));\n    return squareDiffs.reduce((a, b) => a + b, 0) / arr.length;\n};\n\n/**\n * Calculate overall interaction score.\n *\n * @param {Array} anomalies Detected anomalies.\n * @returns {number} Score from 0-100.\n */\nconst calculateInteractionScore = (anomalies) => {\n    if (anomalies.length === 0) {\n        return 0;\n    }\n\n    const totalWeight = anomalies.reduce((sum, a) => sum + (a.weight || 0), 0);\n    const maxPossibleWeight = anomalies.length * 10;\n\n    // Check for \"smoking gun\" combinations that indicate definite agent.\n    const hasSuperhuman = anomalies.some((a) => a.name === 'click.superhuman_speed');\n    const hasCenterPrecision = anomalies.some((a) => a.name === 'click.center_precision');\n    const hasTeleport = anomalies.some((a) => a.name === 'click.teleport_pattern');\n    const hasNoMovement = anomalies.some((a) => a.name === 'click.no_movement');\n    const hasUltraPrecise = anomalies.some((a) => a.name === 'comet.ultra_precise_center');\n    const hasNoTrail = anomalies.some((a) => a.name === 'comet.no_mousemove_trail');\n    const hasReadThenAct = anomalies.some((a) => a.name === 'comet.read_then_act');\n\n    // Multiple strong signals = high confidence agent.\n    let multiplier = 1.0;\n    const strongSignals = [\n        hasSuperhuman, hasCenterPrecision, hasTeleport, hasNoMovement,\n        hasUltraPrecise, hasNoTrail, hasReadThenAct,\n    ].filter(Boolean).length;\n    if (strongSignals >= 3) {\n        multiplier = 1.5; // 3+ strong signals = very likely agent.\n    } else if (strongSignals >= 2) {\n        multiplier = 1.25; // 2 strong signals = boost score.\n    }\n\n    // Normalize and apply scaling.\n    const rawScore = (totalWeight / Math.max(maxPossibleWeight, 30)) * 100 * multiplier;\n    return Math.min(100, Math.round(rawScore));\n};\n\n/**\n * Analyze action bursts — rapid sequences of heterogeneous events\n * preceded by a quiescent period. Characteristic of agentic AI\n * that reads the DOM, pauses to \"think\", then executes rapidly.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzeActionBursts = () => {\n    const anomalies = [];\n\n    // Merge all action events into a sorted timeline.\n    const allActions = [\n        ...eventStore.clicks.map((e) => ({timestamp: e.timestamp, actionType: 'click'})),\n        ...eventStore.keystrokes.filter((k) => k.type === 'down').map((e) => ({timestamp: e.timestamp, actionType: 'keystroke'})),\n        ...eventStore.focusChanges.map((e) => ({timestamp: e.timestamp, actionType: 'focus'})),\n    ].sort((a, b) => a.timestamp - b.timestamp);\n\n    if (allActions.length < 5) {\n        return anomalies;\n    }\n\n    let burstCount = 0;\n    let readThenActCount = 0;\n    let i = 0;\n\n    while (i < allActions.length) {\n        // Find all actions within 2000ms of this one.\n        let windowEnd = i;\n        while (windowEnd < allActions.length &&\n               allActions[windowEnd].timestamp - allActions[i].timestamp < 2000) {\n            windowEnd++;\n        }\n        const burstSize = windowEnd - i;\n        const actionTypes = new Set(\n            allActions.slice(i, windowEnd).map((a) => a.actionType)\n        );\n\n        if (burstSize >= 5 && actionTypes.size >= 2) {\n            burstCount++;\n\n            // Check for preceding quiescent period (3+ seconds gap).\n            if (i > 0) {\n                const gap = allActions[i].timestamp - allActions[i - 1].timestamp;\n                if (gap >= 3000) {\n                    readThenActCount++;\n                }\n            }\n            // Skip past this burst to avoid double-counting.\n            i = windowEnd;\n        } else {\n            i++;\n        }\n    }\n\n    if (burstCount >= 2) {\n        anomalies.push({\n            name: 'comet.action_burst',\n            value: burstCount,\n            weight: 8,\n        });\n    }\n\n    if (readThenActCount >= 1) {\n        anomalies.push({\n            name: 'comet.read_then_act',\n            value: readThenActCount,\n            weight: 9,\n        });\n    }\n\n    return anomalies;\n};\n\n/**\n * Analyze CDP-dispatched click patterns.\n * CDP-dispatched clicks via Input.dispatchMouseEvent lack the natural\n * mousemove trail that precedes a human click.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzeCDPClickPatterns = () => {\n    const anomalies = [];\n    const clicks = eventStore.clicks;\n    const moves = eventStore.mouseMoves;\n\n    if (clicks.length < 3) {\n        return anomalies;\n    }\n\n    // For each click, count mousemoves in the 500ms window before it.\n    let zeroTrailClicks = 0;\n\n    for (const click of clicks) {\n        const precedingMoves = moves.filter((m) =>\n            m.timestamp > click.timestamp - 500 &&\n            m.timestamp < click.timestamp\n        );\n        if (precedingMoves.length === 0) {\n            zeroTrailClicks++;\n        }\n    }\n\n    const ratio = zeroTrailClicks / clicks.length;\n    if (ratio > 0.7) {\n        anomalies.push({\n            name: 'comet.no_mousemove_trail',\n            value: ratio,\n            weight: 9,\n        });\n    }\n\n    return anomalies;\n};\n\n/**\n * Analyze pointer events relative to mouse clicks.\n * Human interactions generate both pointer and mouse events.\n * CDP-dispatched mouse events may lack corresponding pointer events.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzePointerEvents = () => {\n    const anomalies = [];\n    const clicks = eventStore.clicks;\n    const pointerDowns = eventStore.pointerEvents.filter((p) => p.type === 'down');\n\n    if (clicks.length < 3) {\n        return anomalies;\n    }\n\n    const ratio = pointerDowns.length / clicks.length;\n    if (ratio < 0.3) {\n        anomalies.push({\n            name: 'comet.missing_pointer_events',\n            value: ratio,\n            weight: 7,\n        });\n    }\n\n    return anomalies;\n};\n\n/**\n * Get the sessionStorage key for cross-page event accumulation.\n *\n * @returns {string} Storage key scoped by context.\n */\nconst getStorageKey = () => {\n    return contextId ? `agentdetect_events_${contextId}` : 'agentdetect_events';\n};\n\n/**\n * Load accumulated events from sessionStorage (prior pages in same session).\n *\n * @returns {void}\n */\nconst loadFromSessionStorage = () => {\n    try {\n        const stored = sessionStorage.getItem(getStorageKey());\n        if (!stored) {\n            return;\n        }\n        const data = JSON.parse(stored);\n\n        // Restore startTime from the original first page.\n        if (data.startTime) {\n            eventStore.startTime = data.startTime;\n        }\n\n        // Merge stored events — keep the most recent ones within limits.\n        const storeNames = ['mouseMoves', 'clicks', 'keystrokes', 'scrolls', 'focusChanges', 'pointerEvents'];\n        for (const name of storeNames) {\n            if (data[name] && Array.isArray(data[name])) {\n                // Prepend prior events, then trim to max.\n                eventStore[name] = [...data[name], ...eventStore[name]];\n                if (eventStore[name].length > CONFIG.maxStoredEvents) {\n                    eventStore[name] = eventStore[name].slice(-CONFIG.maxStoredEvents);\n                }\n            }\n        }\n\n        // Don't restore hovers — they hold element references which can't be serialised.\n\n        // Invalidate analysis cache since we loaded new data.\n        analysisCache = null;\n    } catch (e) {\n        // sessionStorage unavailable or data corrupt — start fresh.\n    }\n};\n\n/**\n * Save current events to sessionStorage for the next page load.\n * Called on beforeunload to persist cross-page.\n *\n * @returns {void}\n */\nexport const saveToSessionStorage = () => {\n    try {\n        // Save a compressed version — most recent 200 per type, no DOM references.\n        const data = {\n            startTime: eventStore.startTime,\n            mouseMoves: eventStore.mouseMoves.slice(-200),\n            clicks: eventStore.clicks.slice(-200).map((c) => ({\n                x: c.x,\n                y: c.y,\n                timestamp: c.timestamp,\n                offsetFromCenter: c.offsetFromCenter,\n                hadPrecedingHover: c.hadPrecedingHover,\n                hadPrecedingMouseMove: c.hadPrecedingMouseMove,\n                clickDuration: c.clickDuration,\n            })),\n            keystrokes: eventStore.keystrokes.slice(-200).map((k) => ({\n                key: k.key,\n                timestamp: k.timestamp,\n                deltaTime: k.deltaTime,\n                type: k.type,\n                holdDuration: k.holdDuration,\n            })),\n            scrolls: eventStore.scrolls.slice(-200),\n            focusChanges: eventStore.focusChanges.slice(-200).map((f) => ({\n                target: f.target,\n                timestamp: f.timestamp,\n                type: f.type,\n            })),\n            pointerEvents: eventStore.pointerEvents.slice(-200),\n        };\n        sessionStorage.setItem(getStorageKey(), JSON.stringify(data));\n    } catch (e) {\n        // Ignore storage errors (quota exceeded, etc.).\n    }\n};\n\n/**\n * Get raw event data for debugging/inspection.\n *\n * @returns {Object} Event store data.\n */\nexport const getRawData = () => {\n    return {\n        ...eventStore,\n        isMonitoring,\n    };\n};\n\n/**\n * Reset all collected data.\n *\n * @returns {void}\n */\nexport const reset = () => {\n    eventStore.mouseMoves = [];\n    eventStore.clicks = [];\n    eventStore.keystrokes = [];\n    eventStore.scrolls = [];\n    eventStore.hovers = [];\n    eventStore.focusChanges = [];\n    eventStore.pointerEvents = [];\n    eventStore.startTime = Date.now();\n    analysisCache = null;\n};\n\nexport default {\n    startMonitoring,\n    stopMonitoring,\n    analyze,\n    getRawData,\n    reset,\n    saveToSessionStorage,\n    CONFIG,\n};\n"],"names":["CONFIG","minMouseMoves","minClicks","minKeystrokes","perfectTimingVariance","minHumanReactionTime","maxMouseSpeed","centerClickTolerance","maxStoredEvents","analysisInterval","eventStore","mouseMoves","clicks","keystrokes","scrolls","hovers","focusChanges","pointerEvents","startTime","Date","now","contextId","analysisCache","isMonitoring","startMonitoring","options","loadFromSessionStorage","document","addEventListener","handleMouseMove","passive","handleClick","capture","handleMouseDown","handleMouseUp","handleMouseOver","handleMouseOut","handleKeyDown","handleKeyUp","handleScroll","window","handleFocusIn","handleFocusOut","handlePointerDown","handlePointerMove","stopMonitoring","removeEventListener","e","performance","lastMove","length","moveData","x","clientX","y","clientY","timestamp","deltaTime","deltaX","deltaY","distance","Math","sqrt","velocity","addToStore","target","rect","getBoundingClientRect","elementCenterX","left","width","elementCenterY","top","height","offsetFromCenter","clickData","tagName","id","className","hadPrecedingHover","checkPrecedingHover","hadPrecedingMouseMove","checkPrecedingMouseMove","lastClick","mousedownTime","clickDuration","type","lastKeystroke","key","keydowns","filter","k","holdDuration","matchingKeydown","lastScroll","scrollY","scrollX","pointerType","last","storeName","data","push","shift","slice","some","h","recentMoves","m","analyze","results","duration","eventCounts","anomalies","score","analyzeMouseMovement","analyzeClicks","analyzeKeystrokes","analyzeScrolling","analyzeEventSequence","analyzeActionBursts","analyzeCDPClickPatterns","analyzePointerEvents","calculateInteractionScore","moves","name","value","weight","linearSegments","findLinearSegments","teleports","velocities","map","variance","calculateVariance","linearCount","i","angle1","atan2","angle2","abs","cos","centerClicks","c","ultraPreciseClicks","noHoverClicks","noMoveClicks","totalMouseMoves","interClickTimes","fastClicks","t","interKeyTimes","keyMean","reduce","a","b","keyStdDev","keyCV","fastKeys","holdDurations","holdMean","holdStdDev","holdCV","instantScrolls","s","scrollAmounts","v","hoverRatio","max","directFocus","f","focusIns","rapidSequentialFocus","j","gap","differentTarget","arr","mean","pow","totalWeight","sum","maxPossibleWeight","multiplier","strongSignals","Boolean","rawScore","min","round","allActions","actionType","sort","burstCount","readThenActCount","windowEnd","burstSize","actionTypes","Set","size","zeroTrailClicks","click","ratio","pointerDowns","p","getStorageKey","stored","sessionStorage","getItem","JSON","parse","storeNames","Array","isArray","saveToSessionStorage","setItem","stringify","getRawData","reset"],"mappings":"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"}