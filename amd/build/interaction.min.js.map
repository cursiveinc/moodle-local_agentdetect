{"version":3,"file":"interaction.min.js","sources":["../src/interaction.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Interaction anomaly detection module.\n *\n * Monitors user interactions (mouse, keyboard, scroll) to detect\n * patterns typical of automated browsers versus human users.\n *\n * @module     local_agentdetect/interaction\n * @copyright  2024 Your Institution\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n/**\n * Configuration for interaction monitoring.\n *\n * @type {Object}\n */\nconst CONFIG = {\n    // Minimum data points before analysis.\n    minMouseMoves: 20,\n    minClicks: 3,\n    minKeystrokes: 10,\n\n    // Thresholds for anomaly detection.\n    perfectTimingVariance: 5, // Ms - variance below this is suspicious.\n    minHumanReactionTime: 50, // Ms - clicks faster than this are suspicious.\n    maxMouseSpeed: 10000, // Px/ms - movements faster than this are suspicious.\n    centerClickTolerance: 5, // Px - clicks within this of element center are suspicious.\n\n    // Sampling configuration.\n    maxStoredEvents: 500,\n    analysisInterval: 10000, // Ms - how often to run analysis.\n};\n\n/**\n * Event storage for analysis.\n *\n * @type {Object}\n */\nconst eventStore = {\n    mouseMoves: [],\n    clicks: [],\n    keystrokes: [],\n    scrolls: [],\n    hovers: [],\n    focusChanges: [],\n    pointerEvents: [],\n    startTime: Date.now(),\n    pageLoadCount: 1,\n};\n\n/**\n * Context ID for sessionStorage scoping (set in startMonitoring).\n *\n * @type {number|null}\n */\nlet contextId = null;\n\n/**\n * Analysis results cache.\n *\n * @type {Object|null}\n */\nlet analysisCache = null;\n\n/**\n * Whether monitoring is active.\n *\n * @type {boolean}\n */\nlet isMonitoring = false;\n\n/**\n * Start monitoring user interactions.\n *\n * @param {Object} options Configuration options.\n * @param {number} options.contextId Context ID for sessionStorage scoping.\n * @returns {void}\n */\nexport const startMonitoring = (options = {}) => {\n    if (isMonitoring) {\n        return;\n    }\n\n    isMonitoring = true;\n    contextId = options.contextId || null;\n    eventStore.startTime = Date.now();\n\n    // Restore accumulated events from prior pages in this session.\n    loadFromSessionStorage();\n\n    // Mouse movement tracking.\n    document.addEventListener('mousemove', handleMouseMove, {passive: true});\n\n    // Click tracking (capture phase to get all clicks).\n    document.addEventListener('click', handleClick, {capture: true, passive: true});\n    document.addEventListener('mousedown', handleMouseDown, {capture: true, passive: true});\n    document.addEventListener('mouseup', handleMouseUp, {capture: true, passive: true});\n\n    // Hover tracking.\n    document.addEventListener('mouseover', handleMouseOver, {passive: true});\n    document.addEventListener('mouseout', handleMouseOut, {passive: true});\n\n    // Keyboard tracking.\n    document.addEventListener('keydown', handleKeyDown, {capture: true, passive: true});\n    document.addEventListener('keyup', handleKeyUp, {capture: true, passive: true});\n\n    // Scroll tracking.\n    document.addEventListener('scroll', handleScroll, {passive: true});\n    window.addEventListener('scroll', handleScroll, {passive: true});\n\n    // Focus tracking.\n    document.addEventListener('focusin', handleFocusIn, {passive: true});\n    document.addEventListener('focusout', handleFocusOut, {passive: true});\n\n    // Pointer event tracking (for CDP dispatch detection).\n    document.addEventListener('pointerdown', handlePointerDown, {capture: true, passive: true});\n    document.addEventListener('pointermove', handlePointerMove, {passive: true});\n};\n\n/**\n * Stop monitoring user interactions.\n *\n * @returns {void}\n */\nexport const stopMonitoring = () => {\n    if (!isMonitoring) {\n        return;\n    }\n\n    isMonitoring = false;\n\n    document.removeEventListener('mousemove', handleMouseMove);\n    document.removeEventListener('click', handleClick, {capture: true});\n    document.removeEventListener('mousedown', handleMouseDown, {capture: true});\n    document.removeEventListener('mouseup', handleMouseUp, {capture: true});\n    document.removeEventListener('mouseover', handleMouseOver);\n    document.removeEventListener('mouseout', handleMouseOut);\n    document.removeEventListener('keydown', handleKeyDown, {capture: true});\n    document.removeEventListener('keyup', handleKeyUp, {capture: true});\n    document.removeEventListener('scroll', handleScroll);\n    window.removeEventListener('scroll', handleScroll);\n    document.removeEventListener('focusin', handleFocusIn);\n    document.removeEventListener('focusout', handleFocusOut);\n    document.removeEventListener('pointerdown', handlePointerDown, {capture: true});\n    document.removeEventListener('pointermove', handlePointerMove);\n};\n\n/**\n * Handle mouse move events.\n *\n * Uses Date.now() for timestamps so events can be compared across page loads.\n *\n * @param {MouseEvent} e Mouse event.\n */\nconst handleMouseMove = (e) => {\n    const now = Date.now();\n    const lastMove = eventStore.mouseMoves[eventStore.mouseMoves.length - 1];\n\n    const moveData = {\n        x: e.clientX,\n        y: e.clientY,\n        timestamp: now,\n        deltaTime: lastMove ? now - lastMove.timestamp : 0,\n        deltaX: lastMove ? e.clientX - lastMove.x : 0,\n        deltaY: lastMove ? e.clientY - lastMove.y : 0,\n    };\n\n    // Calculate velocity.\n    if (moveData.deltaTime > 0) {\n        const distance = Math.sqrt(moveData.deltaX ** 2 + moveData.deltaY ** 2);\n        moveData.velocity = distance / moveData.deltaTime;\n    }\n\n    addToStore('mouseMoves', moveData);\n};\n\n/**\n * Handle click events.\n *\n * @param {MouseEvent} e Mouse event.\n */\nconst handleClick = (e) => {\n    const now = Date.now();\n    const target = e.target;\n    const rect = target.getBoundingClientRect();\n\n    // Calculate click position relative to element center.\n    const elementCenterX = rect.left + rect.width / 2;\n    const elementCenterY = rect.top + rect.height / 2;\n    const offsetFromCenter = Math.sqrt(\n        (e.clientX - elementCenterX) ** 2 +\n        (e.clientY - elementCenterY) ** 2\n    );\n\n    const clickData = {\n        x: e.clientX,\n        y: e.clientY,\n        timestamp: now,\n        target: {\n            tagName: target.tagName,\n            id: target.id,\n            className: target.className,\n            width: rect.width,\n            height: rect.height,\n        },\n        offsetFromCenter: offsetFromCenter,\n        hadPrecedingHover: checkPrecedingHover(target),\n        hadPrecedingMouseMove: checkPrecedingMouseMove(e.clientX, e.clientY),\n    };\n\n    addToStore('clicks', clickData);\n};\n\n/**\n * Handle mousedown events.\n */\nconst handleMouseDown = () => {\n    // Store for click duration analysis.\n    const lastClick = eventStore.clicks[eventStore.clicks.length - 1];\n    if (lastClick && !lastClick.mousedownTime) {\n        lastClick.mousedownTime = Date.now();\n    }\n};\n\n/**\n * Handle mouseup events.\n */\nconst handleMouseUp = () => {\n    // Calculate click duration.\n    const lastClick = eventStore.clicks[eventStore.clicks.length - 1];\n    if (lastClick && lastClick.mousedownTime) {\n        lastClick.clickDuration = Date.now() - lastClick.mousedownTime;\n    }\n};\n\n/**\n * Handle mouseover events.\n *\n * @param {MouseEvent} e Mouse event.\n */\nconst handleMouseOver = (e) => {\n    addToStore('hovers', {\n        target: e.target,\n        timestamp: Date.now(),\n        type: 'over',\n    });\n};\n\n/**\n * Handle mouseout events.\n *\n * @param {MouseEvent} e Mouse event.\n */\nconst handleMouseOut = (e) => {\n    addToStore('hovers', {\n        target: e.target,\n        timestamp: Date.now(),\n        type: 'out',\n    });\n};\n\n/**\n * Handle keydown events.\n *\n * @param {KeyboardEvent} e Keyboard event.\n */\nconst handleKeyDown = (e) => {\n    const now = Date.now();\n    const lastKeystroke = eventStore.keystrokes[eventStore.keystrokes.length - 1];\n\n    addToStore('keystrokes', {\n        key: e.key.length === 1 ? 'char' : e.key, // Don't store actual characters for privacy.\n        timestamp: now,\n        deltaTime: lastKeystroke ? now - lastKeystroke.timestamp : 0,\n        type: 'down',\n    });\n};\n\n/**\n * Handle keyup events.\n */\nconst handleKeyUp = () => {\n    // Find matching keydown to calculate hold duration.\n    const keydowns = eventStore.keystrokes.filter(\n        (k) => k.type === 'down' && !k.holdDuration\n    );\n    const matchingKeydown = keydowns[keydowns.length - 1];\n    if (matchingKeydown) {\n        matchingKeydown.holdDuration = Date.now() - matchingKeydown.timestamp;\n    }\n};\n\n/**\n * Handle scroll events.\n */\nconst handleScroll = () => {\n    const now = Date.now();\n    const lastScroll = eventStore.scrolls[eventStore.scrolls.length - 1];\n\n    addToStore('scrolls', {\n        scrollY: window.scrollY,\n        scrollX: window.scrollX,\n        timestamp: now,\n        deltaTime: lastScroll ? now - lastScroll.timestamp : 0,\n        deltaY: lastScroll ? window.scrollY - lastScroll.scrollY : 0,\n        deltaX: lastScroll ? window.scrollX - lastScroll.scrollX : 0,\n    });\n};\n\n/**\n * Handle focus in events.\n *\n * @param {FocusEvent} e Focus event.\n */\nconst handleFocusIn = (e) => {\n    addToStore('focusChanges', {\n        target: {\n            tagName: e.target.tagName,\n            id: e.target.id,\n            type: e.target.type,\n        },\n        timestamp: Date.now(),\n        type: 'in',\n    });\n};\n\n/**\n * Handle focus out events.\n *\n * @param {FocusEvent} e Focus event.\n */\nconst handleFocusOut = (e) => {\n    addToStore('focusChanges', {\n        target: {\n            tagName: e.target.tagName,\n            id: e.target.id,\n            type: e.target.type,\n        },\n        timestamp: Date.now(),\n        type: 'out',\n    });\n};\n\n/**\n * Handle pointerdown events for CDP dispatch detection.\n *\n * @param {PointerEvent} e Pointer event.\n */\nconst handlePointerDown = (e) => {\n    addToStore('pointerEvents', {\n        type: 'down',\n        x: e.clientX,\n        y: e.clientY,\n        timestamp: Date.now(),\n        pointerType: e.pointerType,\n    });\n};\n\n/**\n * Handle pointermove events (throttled).\n *\n * @param {PointerEvent} e Pointer event.\n */\nconst handlePointerMove = (e) => {\n    const now = Date.now();\n    const last = eventStore.pointerEvents[eventStore.pointerEvents.length - 1];\n    if (last && now - last.timestamp < 50) {\n        return; // Throttle to 20Hz.\n    }\n    addToStore('pointerEvents', {\n        type: 'move',\n        x: e.clientX,\n        y: e.clientY,\n        timestamp: now,\n        pointerType: e.pointerType,\n    });\n};\n\n/**\n * Timestamp of last periodic save to sessionStorage.\n *\n * @type {number}\n */\nlet lastPeriodicSave = 0;\n\n/**\n * Add event to storage with size limiting.\n *\n * Also periodically saves to sessionStorage so that cross-page\n * accumulation works even when beforeunload does not fire\n * (e.g. CDP-driven page navigations by agents).\n *\n * @param {string} storeName Name of the store.\n * @param {Object} data Event data.\n */\nconst addToStore = (storeName, data) => {\n    eventStore[storeName].push(data);\n\n    // Limit store size.\n    if (eventStore[storeName].length > CONFIG.maxStoredEvents) {\n        eventStore[storeName].shift();\n    }\n\n    // Invalidate cache.\n    analysisCache = null;\n\n    // Periodic save: write to sessionStorage every 2 seconds at most.\n    // This ensures cross-page accumulation even if beforeunload doesn't fire.\n    const now = Date.now();\n    if (now - lastPeriodicSave > 2000) {\n        lastPeriodicSave = now;\n        try {\n            saveToSessionStorage();\n        } catch (e) {\n            // Ignore save errors.\n        }\n    }\n};\n\n/**\n * Check if there was a hover event before this click.\n *\n * @param {Element} target Click target.\n * @returns {boolean} True if hover preceded click.\n */\nconst checkPrecedingHover = (target) => {\n    const recentHovers = eventStore.hovers.slice(-20);\n    return recentHovers.some((h) => h.target === target && h.type === 'over');\n};\n\n/**\n * Check if there was mouse movement leading to click position.\n *\n * @param {number} x Click X coordinate.\n * @param {number} y Click Y coordinate.\n * @returns {boolean} True if mouse movement preceded click.\n */\nconst checkPrecedingMouseMove = (x, y) => {\n    const recentMoves = eventStore.mouseMoves.slice(-10);\n    if (recentMoves.length === 0) {\n        return false;\n    }\n\n    // Check if any recent movement was near the click position.\n    return recentMoves.some((m) => {\n        const distance = Math.sqrt((m.x - x) ** 2 + (m.y - y) ** 2);\n        return distance < 50;\n    });\n};\n\n/**\n * Analyze collected interaction data for anomalies.\n *\n * @returns {Object} Analysis results with anomaly signals.\n */\nexport const analyze = () => {\n    if (analysisCache) {\n        return analysisCache;\n    }\n\n    const results = {\n        timestamp: Date.now(),\n        duration: Date.now() - eventStore.startTime,\n        pageLoadCount: eventStore.pageLoadCount,\n        eventCounts: {\n            mouseMoves: eventStore.mouseMoves.length,\n            clicks: eventStore.clicks.length,\n            keystrokes: eventStore.keystrokes.length,\n            scrolls: eventStore.scrolls.length,\n            hovers: eventStore.hovers.length,\n            focusChanges: eventStore.focusChanges.length,\n            pointerEvents: eventStore.pointerEvents.length,\n        },\n        anomalies: [],\n        score: 0,\n    };\n\n    // Run individual analyses.\n    results.anomalies.push(...analyzeMouseMovement());\n    results.anomalies.push(...analyzeClicks());\n    results.anomalies.push(...analyzeKeystrokes());\n    results.anomalies.push(...analyzeScrolling());\n    results.anomalies.push(...analyzeEventSequence());\n\n    // Comet agentic mode analyses.\n    results.anomalies.push(...analyzeActionBursts());\n    results.anomalies.push(...analyzeCDPClickPatterns());\n    results.anomalies.push(...analyzePointerEvents());\n\n    // Calculate overall score.\n    results.score = calculateInteractionScore(results.anomalies);\n\n    analysisCache = results;\n    return results;\n};\n\n/**\n * Analyze mouse movement patterns.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzeMouseMovement = () => {\n    const anomalies = [];\n    const moves = eventStore.mouseMoves;\n\n    if (moves.length < CONFIG.minMouseMoves) {\n        anomalies.push({\n            name: 'mouse.insufficient_data',\n            value: moves.length,\n            weight: 2,\n        });\n        return anomalies;\n    }\n\n    // Check for perfectly linear movements.\n    // Note: humans trigger this at 0.44-0.57 so it's a weak signal.\n    const linearSegments = findLinearSegments(moves);\n    if (linearSegments > moves.length * 0.3) {\n        anomalies.push({\n            name: 'mouse.linear_movement',\n            value: linearSegments / moves.length,\n            weight: 3, // Reduced from 7 — humans trigger this often.\n        });\n    }\n\n    // Check for teleporting (instant position changes).\n    const teleports = moves.filter((m) => m.velocity > CONFIG.maxMouseSpeed);\n    if (teleports.length > 0) {\n        anomalies.push({\n            name: 'mouse.teleport',\n            value: teleports.length,\n            weight: 8,\n        });\n    }\n\n    // Check for no mouse movement at all (common in automated tests).\n    const duration = Date.now() - eventStore.startTime;\n    if (moves.length < duration / 5000) { // Less than 1 move per 5 seconds.\n        anomalies.push({\n            name: 'mouse.sparse_movement',\n            value: moves.length,\n            weight: 5,\n        });\n    }\n\n    // Check velocity variance (humans have high variance).\n    const velocities = moves.filter((m) => m.velocity).map((m) => m.velocity);\n    if (velocities.length > 5) {\n        const variance = calculateVariance(velocities);\n        if (variance < 0.1) {\n            anomalies.push({\n                name: 'mouse.constant_velocity',\n                value: variance,\n                weight: 6,\n            });\n        }\n    }\n\n    // KEY SIGNAL: Mouse-to-action ratio.\n    // Humans generate many mouse moves per click (typically 20-100+).\n    // CDP-driven agents generate almost no mouse moves (0-3 per click).\n    // This is the strongest real-world differentiator from test data.\n    const totalActions = eventStore.clicks.length + eventStore.keystrokes.filter((k) => k.type === 'down').length;\n    if (totalActions >= 3 && eventStore.pageLoadCount >= 2) {\n        const movePerAction = moves.length / totalActions;\n        if (movePerAction < 2) {\n            // Almost no mouse movement relative to actions — very strong agent signal.\n            anomalies.push({\n                name: 'comet.low_mouse_to_action_ratio',\n                value: movePerAction,\n                weight: 10,\n            });\n        } else if (movePerAction < 5) {\n            // Very low mouse movement — suspicious.\n            anomalies.push({\n                name: 'comet.low_mouse_to_action_ratio',\n                value: movePerAction,\n                weight: 7,\n            });\n        }\n    }\n\n    return anomalies;\n};\n\n/**\n * Find linear segments in mouse movement.\n *\n * @param {Array} moves Mouse move events.\n * @returns {number} Count of linear segments.\n */\nconst findLinearSegments = (moves) => {\n    let linearCount = 0;\n    const threshold = 0.99; // Angle consistency threshold.\n\n    for (let i = 2; i < moves.length; i++) {\n        const angle1 = Math.atan2(\n            moves[i - 1].y - moves[i - 2].y,\n            moves[i - 1].x - moves[i - 2].x\n        );\n        const angle2 = Math.atan2(\n            moves[i].y - moves[i - 1].y,\n            moves[i].x - moves[i - 1].x\n        );\n\n        if (Math.abs(Math.cos(angle1 - angle2)) > threshold) {\n            linearCount++;\n        }\n    }\n\n    return linearCount;\n};\n\n/**\n * Analyze click patterns.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzeClicks = () => {\n    const anomalies = [];\n    const clicks = eventStore.clicks;\n\n    if (clicks.length < CONFIG.minClicks) {\n        return anomalies;\n    }\n\n    // Check for clicks at exact element centers (agents click perfectly).\n    const centerClicks = clicks.filter(\n        (c) => c.offsetFromCenter < CONFIG.centerClickTolerance\n    );\n    if (centerClicks.length > clicks.length * 0.5) {\n        anomalies.push({\n            name: 'click.center_precision',\n            value: centerClicks.length / clicks.length,\n            weight: 10, // Increased - strong agent indicator.\n        });\n    }\n\n    // Ultra-precise center clicks (< 2px offset) -- strong agentic indicator.\n    // Agents target elements by reference, landing at exact computed center.\n    const ultraPreciseClicks = clicks.filter(\n        (c) => c.offsetFromCenter < 2\n    );\n    if (ultraPreciseClicks.length > clicks.length * 0.6 && clicks.length >= 3) {\n        anomalies.push({\n            name: 'comet.ultra_precise_center',\n            value: ultraPreciseClicks.length / clicks.length,\n            weight: 10,\n        });\n    }\n\n    // Check for clicks without preceding hover.\n    const noHoverClicks = clicks.filter((c) => !c.hadPrecedingHover);\n    if (noHoverClicks.length > clicks.length * 0.7) {\n        anomalies.push({\n            name: 'click.no_hover',\n            value: noHoverClicks.length / clicks.length,\n            weight: 6,\n        });\n    }\n\n    // Check for clicks without preceding mouse movement (teleport clicks).\n    const noMoveClicks = clicks.filter((c) => !c.hadPrecedingMouseMove);\n    if (noMoveClicks.length > clicks.length * 0.5) {\n        anomalies.push({\n            name: 'click.no_movement',\n            value: noMoveClicks.length / clicks.length,\n            weight: 9, // Increased - agents teleport to click targets.\n        });\n    }\n\n    // STRONG INDICATOR: Clicks with NO mouse data at all (pure teleport).\n    const totalMouseMoves = eventStore.mouseMoves.length;\n    if (clicks.length >= 3 && totalMouseMoves < clicks.length * 2) {\n        anomalies.push({\n            name: 'click.teleport_pattern',\n            value: totalMouseMoves / clicks.length,\n            weight: 10, // Very strong - humans move mouse much more than they click.\n        });\n    }\n\n    // Check for impossibly fast clicks (< 50ms reaction time).\n    // Note: humans trigger this with rapid double-clicks, so not definitive alone.\n    const interClickTimes = [];\n    for (let i = 1; i < clicks.length; i++) {\n        interClickTimes.push(clicks[i].timestamp - clicks[i - 1].timestamp);\n    }\n    const fastClicks = interClickTimes.filter((t) => t < CONFIG.minHumanReactionTime);\n    if (fastClicks.length > 0) {\n        anomalies.push({\n            name: 'click.superhuman_speed',\n            value: fastClicks.length,\n            weight: 6, // Reduced from 10 — humans can rapid-click too.\n        });\n    }\n\n    // Check for perfectly regular click timing.\n    if (interClickTimes.length >= 3) {\n        const variance = calculateVariance(interClickTimes);\n        if (variance < CONFIG.perfectTimingVariance) {\n            anomalies.push({\n                name: 'click.perfect_timing',\n                value: variance,\n                weight: 8,\n            });\n        }\n    }\n\n    return anomalies;\n};\n\n/**\n * Analyze keystroke patterns.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzeKeystrokes = () => {\n    const anomalies = [];\n    const keystrokes = eventStore.keystrokes.filter((k) => k.type === 'down');\n\n    if (keystrokes.length < CONFIG.minKeystrokes) {\n        return anomalies;\n    }\n\n    // Check inter-key timing variance.\n    const interKeyTimes = keystrokes.slice(1).map((k) => k.deltaTime);\n    if (interKeyTimes.length >= 5) {\n        const variance = calculateVariance(interKeyTimes);\n        if (variance < CONFIG.perfectTimingVariance) {\n            anomalies.push({\n                name: 'keystroke.perfect_timing',\n                value: variance,\n                weight: 9,\n            });\n        }\n    }\n\n    // Comet-specific: check coefficient of variation for inter-key timing.\n    // Human typing has CV > 0.3; agent-dispatched keystrokes have CV < 0.1.\n    const keyMean = interKeyTimes.reduce((a, b) => a + b, 0) / interKeyTimes.length;\n    const keyStdDev = Math.sqrt(calculateVariance(interKeyTimes));\n    const keyCV = keyMean > 0 ? keyStdDev / keyMean : 0;\n\n    if (keyCV < 0.1 && interKeyTimes.length >= 10) {\n        anomalies.push({\n            name: 'comet.uniform_keystroke_cadence',\n            value: keyCV,\n            weight: 9,\n        });\n    }\n\n    // Check for impossibly fast typing (< 30ms between keys is ~2000 WPM).\n    const fastKeys = interKeyTimes.filter((t) => t > 0 && t < 30);\n    if (fastKeys.length > interKeyTimes.length * 0.3) {\n        anomalies.push({\n            name: 'keystroke.superhuman_speed',\n            value: fastKeys.length / interKeyTimes.length,\n            weight: 9,\n        });\n    }\n\n    // Check key hold duration variance.\n    const holdDurations = keystrokes.filter((k) => k.holdDuration).map((k) => k.holdDuration);\n    if (holdDurations.length >= 5) {\n        const variance = calculateVariance(holdDurations);\n        if (variance < 1) {\n            anomalies.push({\n                name: 'keystroke.constant_hold',\n                value: variance,\n                weight: 7,\n            });\n        }\n\n        // Comet-specific: check hold duration coefficient of variation.\n        if (holdDurations.length >= 10) {\n            const holdMean = holdDurations.reduce((a, b) => a + b, 0) / holdDurations.length;\n            const holdStdDev = Math.sqrt(calculateVariance(holdDurations));\n            const holdCV = holdMean > 0 ? holdStdDev / holdMean : 0;\n\n            if (holdCV < 0.1) {\n                anomalies.push({\n                    name: 'comet.uniform_hold_duration',\n                    value: holdCV,\n                    weight: 8,\n                });\n            }\n        }\n    }\n\n    return anomalies;\n};\n\n/**\n * Analyze scrolling patterns.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzeScrolling = () => {\n    const anomalies = [];\n    const scrolls = eventStore.scrolls;\n\n    if (scrolls.length < 3) {\n        return anomalies;\n    }\n\n    // Check for instant scroll jumps (no smooth scrolling).\n    const instantScrolls = scrolls.filter((s) => s.deltaTime < 10 && Math.abs(s.deltaY) > 100);\n    if (instantScrolls.length > scrolls.length * 0.5) {\n        anomalies.push({\n            name: 'scroll.instant_jump',\n            value: instantScrolls.length / scrolls.length,\n            weight: 6,\n        });\n    }\n\n    // Check for perfectly regular scroll amounts.\n    const scrollAmounts = scrolls.map((s) => Math.abs(s.deltaY)).filter((v) => v > 0);\n    if (scrollAmounts.length >= 3) {\n        const variance = calculateVariance(scrollAmounts);\n        if (variance < 1) {\n            anomalies.push({\n                name: 'scroll.constant_amount',\n                value: variance,\n                weight: 5,\n            });\n        }\n    }\n\n    return anomalies;\n};\n\n/**\n * Analyze event sequence patterns.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzeEventSequence = () => {\n    const anomalies = [];\n\n    // Check for missing event sequences (e.g., click without mousedown).\n    // Automated tools sometimes skip intermediate events.\n\n    // Check ratio of hovers to clicks (humans hover a lot before clicking).\n    const hoverRatio = eventStore.hovers.length / Math.max(eventStore.clicks.length, 1);\n    if (hoverRatio < 2 && eventStore.clicks.length >= CONFIG.minClicks) {\n        anomalies.push({\n            name: 'sequence.low_hover_ratio',\n            value: hoverRatio,\n            weight: 5,\n        });\n    }\n\n    // Check for focus changes without preceding clicks or tabs.\n    // Direct focus (via JS) is common in automation.\n    const directFocus = eventStore.focusChanges.filter((f) => {\n        // Check if there was a recent click or keystroke.\n        const recentEvents = [\n            ...eventStore.clicks.slice(-5),\n            ...eventStore.keystrokes.slice(-5),\n        ];\n        const hasRecentInteraction = recentEvents.some(\n            (e) => Math.abs(e.timestamp - f.timestamp) < 100\n        );\n        return !hasRecentInteraction;\n    });\n\n    if (directFocus.length > eventStore.focusChanges.length * 0.5 &&\n        eventStore.focusChanges.length >= 3) {\n        anomalies.push({\n            name: 'sequence.direct_focus',\n            value: directFocus.length / eventStore.focusChanges.length,\n            weight: 6,\n        });\n    }\n\n    // Rapid sequential focus changes across different form fields.\n    // Agents navigate fields programmatically, producing near-instant focus changes.\n    const focusIns = eventStore.focusChanges.filter((f) => f.type === 'in');\n    if (focusIns.length >= 3) {\n        let rapidSequentialFocus = 0;\n        for (let j = 1; j < focusIns.length; j++) {\n            const gap = focusIns[j].timestamp - focusIns[j - 1].timestamp;\n            const differentTarget = focusIns[j].target.id !== focusIns[j - 1].target.id;\n            if (gap < 200 && differentTarget) {\n                rapidSequentialFocus++;\n            }\n        }\n        if (rapidSequentialFocus >= 2) {\n            anomalies.push({\n                name: 'comet.rapid_focus_sequence',\n                value: rapidSequentialFocus,\n                weight: 7,\n            });\n        }\n    }\n\n    return anomalies;\n};\n\n/**\n * Calculate variance of an array of numbers.\n *\n * @param {Array<number>} arr Array of numbers.\n * @returns {number} Variance.\n */\nconst calculateVariance = (arr) => {\n    if (arr.length < 2) {\n        return 0;\n    }\n    const mean = arr.reduce((a, b) => a + b, 0) / arr.length;\n    const squareDiffs = arr.map((value) => Math.pow(value - mean, 2));\n    return squareDiffs.reduce((a, b) => a + b, 0) / arr.length;\n};\n\n/**\n * Calculate overall interaction score.\n *\n * Applies a confidence discount when total events are low, to avoid\n * false positives from sparse data (e.g. a single quiz page with 2 clicks).\n *\n * @param {Array} anomalies Detected anomalies.\n * @returns {number} Score from 0-100.\n */\nconst calculateInteractionScore = (anomalies) => {\n    if (anomalies.length === 0) {\n        return 0;\n    }\n\n    const totalWeight = anomalies.reduce((sum, a) => sum + (a.weight || 0), 0);\n    const maxPossibleWeight = anomalies.length * 10;\n\n    // Check for \"smoking gun\" combinations that indicate definite agent.\n    const hasSuperhuman = anomalies.some((a) => a.name === 'click.superhuman_speed');\n    const hasCenterPrecision = anomalies.some((a) => a.name === 'click.center_precision');\n    const hasTeleport = anomalies.some((a) => a.name === 'click.teleport_pattern');\n    const hasNoMovement = anomalies.some((a) => a.name === 'click.no_movement');\n    const hasUltraPrecise = anomalies.some((a) => a.name === 'comet.ultra_precise_center');\n    const hasNoTrail = anomalies.some((a) => a.name === 'comet.no_mousemove_trail');\n    const hasReadThenAct = anomalies.some((a) => a.name === 'comet.read_then_act');\n    const hasLowMouseRatio = anomalies.some((a) => a.name === 'comet.low_mouse_to_action_ratio');\n\n    // Multiple strong signals = high confidence agent.\n    let multiplier = 1.0;\n    const strongSignals = [\n        hasSuperhuman, hasCenterPrecision, hasTeleport, hasNoMovement,\n        hasUltraPrecise, hasNoTrail, hasReadThenAct, hasLowMouseRatio,\n    ].filter(Boolean).length;\n    if (strongSignals >= 3) {\n        multiplier = 1.5; // 3+ strong signals = very likely agent.\n    } else if (strongSignals >= 2) {\n        multiplier = 1.25; // 2 strong signals = boost score.\n    }\n\n    // Normalize and apply scaling.\n    let rawScore = (totalWeight / Math.max(maxPossibleWeight, 30)) * 100 * multiplier;\n\n    // Confidence discount: with very few events, ratios are unreliable.\n    // A human clicking 3 times with 2 mouse moves looks identical to an agent.\n    // Require more data before giving high scores.\n    const totalActions = eventStore.clicks.length + eventStore.keystrokes.length;\n    const totalMoves = eventStore.mouseMoves.length;\n    const totalEvents = totalActions + totalMoves;\n\n    if (totalEvents < 10) {\n        // Very sparse — heavily discount unless smoking-gun signals present.\n        // Center_precision is reliable even with few events; teleport_pattern is not.\n        const hasReliableSignal = hasCenterPrecision || hasUltraPrecise || hasNoTrail || hasLowMouseRatio;\n        if (!hasReliableSignal) {\n            rawScore *= 0.3; // 70% discount for ratio-only signals with sparse data.\n        } else {\n            rawScore *= 0.7; // 30% discount even with reliable signals if data is sparse.\n        }\n    } else if (totalEvents < 25) {\n        // Moderate data — small discount.\n        rawScore *= 0.85;\n    }\n    // 25+ events = full confidence, no discount.\n\n    return Math.min(100, Math.round(rawScore));\n};\n\n/**\n * Analyze action bursts — rapid sequences of heterogeneous events\n * preceded by a quiescent period. Characteristic of agentic AI\n * that reads the DOM, pauses to \"think\", then executes rapidly.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzeActionBursts = () => {\n    const anomalies = [];\n\n    // Merge all action events into a sorted timeline.\n    const allActions = [\n        ...eventStore.clicks.map((e) => ({timestamp: e.timestamp, actionType: 'click'})),\n        ...eventStore.keystrokes.filter((k) => k.type === 'down').map((e) => ({timestamp: e.timestamp, actionType: 'keystroke'})),\n        ...eventStore.focusChanges.map((e) => ({timestamp: e.timestamp, actionType: 'focus'})),\n    ].sort((a, b) => a.timestamp - b.timestamp);\n\n    if (allActions.length < 5) {\n        return anomalies;\n    }\n\n    let burstCount = 0;\n    let readThenActCount = 0;\n    let i = 0;\n\n    while (i < allActions.length) {\n        // Find all actions within 2000ms of this one.\n        let windowEnd = i;\n        while (windowEnd < allActions.length &&\n               allActions[windowEnd].timestamp - allActions[i].timestamp < 2000) {\n            windowEnd++;\n        }\n        const burstSize = windowEnd - i;\n        const actionTypes = new Set(\n            allActions.slice(i, windowEnd).map((a) => a.actionType)\n        );\n\n        if (burstSize >= 5 && actionTypes.size >= 2) {\n            burstCount++;\n\n            // Check for preceding quiescent period (3+ seconds gap).\n            if (i > 0) {\n                const gap = allActions[i].timestamp - allActions[i - 1].timestamp;\n                if (gap >= 3000) {\n                    readThenActCount++;\n                }\n            }\n            // Skip past this burst to avoid double-counting.\n            i = windowEnd;\n        } else {\n            i++;\n        }\n    }\n\n    if (burstCount >= 2) {\n        anomalies.push({\n            name: 'comet.action_burst',\n            value: burstCount,\n            weight: 8,\n        });\n    }\n\n    if (readThenActCount >= 1) {\n        anomalies.push({\n            name: 'comet.read_then_act',\n            value: readThenActCount,\n            weight: 9,\n        });\n    }\n\n    return anomalies;\n};\n\n/**\n * Analyze CDP-dispatched click patterns.\n * CDP-dispatched clicks via Input.dispatchMouseEvent lack the natural\n * mousemove trail that precedes a human click.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzeCDPClickPatterns = () => {\n    const anomalies = [];\n    const clicks = eventStore.clicks;\n    const moves = eventStore.mouseMoves;\n\n    if (clicks.length < 3) {\n        return anomalies;\n    }\n\n    // For each click, count mousemoves in the 500ms window before it.\n    let zeroTrailClicks = 0;\n\n    for (const click of clicks) {\n        const precedingMoves = moves.filter((m) =>\n            m.timestamp > click.timestamp - 500 &&\n            m.timestamp < click.timestamp\n        );\n        if (precedingMoves.length === 0) {\n            zeroTrailClicks++;\n        }\n    }\n\n    const ratio = zeroTrailClicks / clicks.length;\n    if (ratio > 0.7) {\n        anomalies.push({\n            name: 'comet.no_mousemove_trail',\n            value: ratio,\n            weight: 9,\n        });\n    }\n\n    return anomalies;\n};\n\n/**\n * Analyze pointer events relative to mouse clicks.\n * Human interactions generate both pointer and mouse events.\n * CDP-dispatched mouse events may lack corresponding pointer events.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzePointerEvents = () => {\n    const anomalies = [];\n    const clicks = eventStore.clicks;\n    const pointerDowns = eventStore.pointerEvents.filter((p) => p.type === 'down');\n\n    if (clicks.length < 3) {\n        return anomalies;\n    }\n\n    const ratio = pointerDowns.length / clicks.length;\n    if (ratio < 0.3) {\n        anomalies.push({\n            name: 'comet.missing_pointer_events',\n            value: ratio,\n            weight: 7,\n        });\n    }\n\n    return anomalies;\n};\n\n/**\n * Get the sessionStorage key for cross-page event accumulation.\n *\n * @returns {string} Storage key scoped by context.\n */\nconst getStorageKey = () => {\n    return contextId ? `agentdetect_events_${contextId}` : 'agentdetect_events';\n};\n\n/**\n * Load accumulated events from sessionStorage (prior pages in same session).\n *\n * @returns {void}\n */\nconst loadFromSessionStorage = () => {\n    try {\n        const stored = sessionStorage.getItem(getStorageKey());\n        if (!stored) {\n            return;\n        }\n        const data = JSON.parse(stored);\n\n        // Restore startTime from the original first page.\n        if (data.startTime) {\n            eventStore.startTime = data.startTime;\n        }\n\n        // Restore page load count and increment.\n        eventStore.pageLoadCount = (data.pageLoadCount || 1) + 1;\n\n        // Merge stored events — keep the most recent ones within limits.\n        const storeNames = ['mouseMoves', 'clicks', 'keystrokes', 'scrolls', 'focusChanges', 'pointerEvents'];\n        for (const name of storeNames) {\n            if (data[name] && Array.isArray(data[name])) {\n                // Prepend prior events, then trim to max.\n                eventStore[name] = [...data[name], ...eventStore[name]];\n                if (eventStore[name].length > CONFIG.maxStoredEvents) {\n                    eventStore[name] = eventStore[name].slice(-CONFIG.maxStoredEvents);\n                }\n            }\n        }\n\n        // Don't restore hovers — they hold element references which can't be serialised.\n\n        // Invalidate analysis cache since we loaded new data.\n        analysisCache = null;\n    } catch (e) {\n        // SessionStorage unavailable or data corrupt — start fresh.\n    }\n};\n\n/**\n * Save current events to sessionStorage for the next page load.\n * Called on beforeunload to persist cross-page.\n *\n * @returns {void}\n */\nexport const saveToSessionStorage = () => {\n    try {\n        // Save a compressed version — most recent 200 per type, no DOM references.\n        const data = {\n            startTime: eventStore.startTime,\n            pageLoadCount: eventStore.pageLoadCount,\n            mouseMoves: eventStore.mouseMoves.slice(-200),\n            clicks: eventStore.clicks.slice(-200).map((c) => ({\n                x: c.x,\n                y: c.y,\n                timestamp: c.timestamp,\n                offsetFromCenter: c.offsetFromCenter,\n                hadPrecedingHover: c.hadPrecedingHover,\n                hadPrecedingMouseMove: c.hadPrecedingMouseMove,\n                clickDuration: c.clickDuration,\n            })),\n            keystrokes: eventStore.keystrokes.slice(-200).map((k) => ({\n                key: k.key,\n                timestamp: k.timestamp,\n                deltaTime: k.deltaTime,\n                type: k.type,\n                holdDuration: k.holdDuration,\n            })),\n            scrolls: eventStore.scrolls.slice(-200),\n            focusChanges: eventStore.focusChanges.slice(-200).map((f) => ({\n                target: f.target,\n                timestamp: f.timestamp,\n                type: f.type,\n            })),\n            pointerEvents: eventStore.pointerEvents.slice(-200),\n        };\n        sessionStorage.setItem(getStorageKey(), JSON.stringify(data));\n    } catch (e) {\n        // Ignore storage errors (quota exceeded, etc.).\n    }\n};\n\n/**\n * Get raw event data for debugging/inspection.\n *\n * @returns {Object} Event store data.\n */\nexport const getRawData = () => {\n    return {\n        ...eventStore,\n        isMonitoring,\n    };\n};\n\n/**\n * Reset all collected data.\n *\n * @returns {void}\n */\nexport const reset = () => {\n    eventStore.mouseMoves = [];\n    eventStore.clicks = [];\n    eventStore.keystrokes = [];\n    eventStore.scrolls = [];\n    eventStore.hovers = [];\n    eventStore.focusChanges = [];\n    eventStore.pointerEvents = [];\n    eventStore.startTime = Date.now();\n    eventStore.pageLoadCount = 1;\n    analysisCache = null;\n};\n\nexport default {\n    startMonitoring,\n    stopMonitoring,\n    analyze,\n    getRawData,\n    reset,\n    saveToSessionStorage,\n    CONFIG,\n};\n"],"names":["CONFIG","minMouseMoves","minClicks","minKeystrokes","perfectTimingVariance","minHumanReactionTime","maxMouseSpeed","centerClickTolerance","maxStoredEvents","analysisInterval","eventStore","mouseMoves","clicks","keystrokes","scrolls","hovers","focusChanges","pointerEvents","startTime","Date","now","pageLoadCount","contextId","analysisCache","isMonitoring","startMonitoring","options","loadFromSessionStorage","document","addEventListener","handleMouseMove","passive","handleClick","capture","handleMouseDown","handleMouseUp","handleMouseOver","handleMouseOut","handleKeyDown","handleKeyUp","handleScroll","window","handleFocusIn","handleFocusOut","handlePointerDown","handlePointerMove","stopMonitoring","removeEventListener","e","lastMove","length","moveData","x","clientX","y","clientY","timestamp","deltaTime","deltaX","deltaY","distance","Math","sqrt","velocity","addToStore","target","rect","getBoundingClientRect","elementCenterX","left","width","elementCenterY","top","height","offsetFromCenter","clickData","tagName","id","className","hadPrecedingHover","checkPrecedingHover","hadPrecedingMouseMove","checkPrecedingMouseMove","lastClick","mousedownTime","clickDuration","type","lastKeystroke","key","keydowns","filter","k","holdDuration","matchingKeydown","lastScroll","scrollY","scrollX","pointerType","last","lastPeriodicSave","storeName","data","push","shift","saveToSessionStorage","slice","some","h","recentMoves","m","analyze","results","duration","eventCounts","anomalies","score","analyzeMouseMovement","analyzeClicks","analyzeKeystrokes","analyzeScrolling","analyzeEventSequence","analyzeActionBursts","analyzeCDPClickPatterns","analyzePointerEvents","calculateInteractionScore","moves","name","value","weight","linearSegments","findLinearSegments","teleports","velocities","map","variance","calculateVariance","totalActions","movePerAction","linearCount","i","angle1","atan2","angle2","abs","cos","centerClicks","c","ultraPreciseClicks","noHoverClicks","noMoveClicks","totalMouseMoves","interClickTimes","fastClicks","t","interKeyTimes","keyMean","reduce","a","b","keyStdDev","keyCV","fastKeys","holdDurations","holdMean","holdStdDev","holdCV","instantScrolls","s","scrollAmounts","v","hoverRatio","max","directFocus","f","focusIns","rapidSequentialFocus","j","gap","differentTarget","arr","mean","pow","totalWeight","sum","maxPossibleWeight","hasSuperhuman","hasCenterPrecision","hasTeleport","hasNoMovement","hasUltraPrecise","hasNoTrail","hasReadThenAct","hasLowMouseRatio","multiplier","strongSignals","Boolean","rawScore","totalEvents","min","round","allActions","actionType","sort","burstCount","readThenActCount","windowEnd","burstSize","actionTypes","Set","size","zeroTrailClicks","click","ratio","pointerDowns","p","getStorageKey","stored","sessionStorage","getItem","JSON","parse","storeNames","Array","isArray","setItem","stringify","getRawData","reset"],"mappings":"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"}