{"version":3,"file":"interaction.min.js","sources":["../src/interaction.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Interaction anomaly detection module.\n *\n * Monitors user interactions (mouse, keyboard, scroll) to detect\n * patterns typical of automated browsers versus human users.\n *\n * @module     local_agentdetect/interaction\n * @copyright  2026 Cursive Technology <joe@cursivetechnology.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n/**\n * Configuration for interaction monitoring.\n *\n * @type {Object}\n */\nconst CONFIG = {\n    // Minimum data points before analysis.\n    minMouseMoves: 20,\n    minClicks: 3,\n    minKeystrokes: 10,\n\n    // Thresholds for anomaly detection.\n    perfectTimingVariance: 5, // Ms - variance below this is suspicious.\n    minHumanReactionTime: 50, // Ms - clicks faster than this are suspicious.\n    maxMouseSpeed: 10000, // Px/ms - movements faster than this are suspicious.\n    centerClickTolerance: 5, // Px - clicks within this of element center are suspicious.\n\n    // Sampling configuration.\n    maxStoredEvents: 500,\n    analysisInterval: 10000, // Ms - how often to run analysis.\n};\n\n/**\n * Event storage for analysis.\n *\n * @type {Object}\n */\nconst eventStore = {\n    mouseMoves: [],\n    clicks: [],\n    keystrokes: [],\n    scrolls: [],\n    hovers: [],\n    focusChanges: [],\n    pointerEvents: [],\n    startTime: Date.now(),\n    pageLoadCount: 1,\n    pageStartTime: Date.now(), // Timestamp when the current page loaded (not overwritten by restore).\n    perPageStats: [], // Per-page {moves, clicks, keys, scrolls} from prior pages.\n};\n\n/**\n * Context ID for sessionStorage scoping (set in startMonitoring).\n *\n * @type {number|null}\n */\nlet contextId = null;\n\n/**\n * Analysis results cache.\n *\n * @type {Object|null}\n */\nlet analysisCache = null;\n\n/**\n * Whether monitoring is active.\n *\n * @type {boolean}\n */\nlet isMonitoring = false;\n\n/**\n * Start monitoring user interactions.\n *\n * @param {Object} options Configuration options.\n * @param {number} options.contextId Context ID for sessionStorage scoping.\n * @returns {void}\n */\nexport const startMonitoring = (options = {}) => {\n    if (isMonitoring) {\n        return;\n    }\n\n    isMonitoring = true;\n    contextId = options.contextId || null;\n    eventStore.startTime = Date.now();\n    eventStore.pageStartTime = Date.now();\n\n    // Restore accumulated events from prior pages in this session.\n    // Note: loadFromSessionStorage overwrites startTime with the session origin\n    // but pageStartTime stays as the current page's load time.\n    loadFromSessionStorage();\n\n    // Mouse movement tracking.\n    document.addEventListener('mousemove', handleMouseMove, {passive: true});\n\n    // Click tracking (capture phase to get all clicks).\n    document.addEventListener('click', handleClick, {capture: true, passive: true});\n    document.addEventListener('mousedown', handleMouseDown, {capture: true, passive: true});\n    document.addEventListener('mouseup', handleMouseUp, {capture: true, passive: true});\n\n    // Hover tracking.\n    document.addEventListener('mouseover', handleMouseOver, {passive: true});\n    document.addEventListener('mouseout', handleMouseOut, {passive: true});\n\n    // Keyboard tracking.\n    document.addEventListener('keydown', handleKeyDown, {capture: true, passive: true});\n    document.addEventListener('keyup', handleKeyUp, {capture: true, passive: true});\n\n    // Scroll tracking.\n    document.addEventListener('scroll', handleScroll, {passive: true});\n    window.addEventListener('scroll', handleScroll, {passive: true});\n\n    // Focus tracking.\n    document.addEventListener('focusin', handleFocusIn, {passive: true});\n    document.addEventListener('focusout', handleFocusOut, {passive: true});\n\n    // Pointer event tracking (for CDP dispatch detection).\n    document.addEventListener('pointerdown', handlePointerDown, {capture: true, passive: true});\n    document.addEventListener('pointermove', handlePointerMove, {passive: true});\n};\n\n/**\n * Stop monitoring user interactions.\n *\n * @returns {void}\n */\nexport const stopMonitoring = () => {\n    if (!isMonitoring) {\n        return;\n    }\n\n    isMonitoring = false;\n\n    document.removeEventListener('mousemove', handleMouseMove);\n    document.removeEventListener('click', handleClick, {capture: true});\n    document.removeEventListener('mousedown', handleMouseDown, {capture: true});\n    document.removeEventListener('mouseup', handleMouseUp, {capture: true});\n    document.removeEventListener('mouseover', handleMouseOver);\n    document.removeEventListener('mouseout', handleMouseOut);\n    document.removeEventListener('keydown', handleKeyDown, {capture: true});\n    document.removeEventListener('keyup', handleKeyUp, {capture: true});\n    document.removeEventListener('scroll', handleScroll);\n    window.removeEventListener('scroll', handleScroll);\n    document.removeEventListener('focusin', handleFocusIn);\n    document.removeEventListener('focusout', handleFocusOut);\n    document.removeEventListener('pointerdown', handlePointerDown, {capture: true});\n    document.removeEventListener('pointermove', handlePointerMove);\n};\n\n/**\n * Handle mouse move events.\n *\n * Uses Date.now() for timestamps so events can be compared across page loads.\n *\n * @param {MouseEvent} e Mouse event.\n */\nconst handleMouseMove = (e) => {\n    const now = Date.now();\n    const lastMove = eventStore.mouseMoves[eventStore.mouseMoves.length - 1];\n\n    const moveData = {\n        x: e.clientX,\n        y: e.clientY,\n        timestamp: now,\n        deltaTime: lastMove ? now - lastMove.timestamp : 0,\n        deltaX: lastMove ? e.clientX - lastMove.x : 0,\n        deltaY: lastMove ? e.clientY - lastMove.y : 0,\n    };\n\n    // Calculate velocity.\n    if (moveData.deltaTime > 0) {\n        const distance = Math.sqrt(moveData.deltaX ** 2 + moveData.deltaY ** 2);\n        moveData.velocity = distance / moveData.deltaTime;\n    }\n\n    addToStore('mouseMoves', moveData);\n};\n\n/**\n * Handle click events.\n *\n * @param {MouseEvent} e Mouse event.\n */\nconst handleClick = (e) => {\n    const now = Date.now();\n    const target = e.target;\n    const rect = target.getBoundingClientRect();\n\n    // Calculate click position relative to element center.\n    const elementCenterX = rect.left + rect.width / 2;\n    const elementCenterY = rect.top + rect.height / 2;\n    const offsetFromCenter = Math.sqrt(\n        (e.clientX - elementCenterX) ** 2 +\n        (e.clientY - elementCenterY) ** 2\n    );\n\n    const clickData = {\n        x: e.clientX,\n        y: e.clientY,\n        timestamp: now,\n        target: {\n            tagName: target.tagName,\n            id: target.id,\n            className: target.className,\n            width: rect.width,\n            height: rect.height,\n        },\n        offsetFromCenter: offsetFromCenter,\n        hadPrecedingHover: checkPrecedingHover(target),\n        hadPrecedingMouseMove: checkPrecedingMouseMove(e.clientX, e.clientY),\n    };\n\n    addToStore('clicks', clickData);\n};\n\n/**\n * Handle mousedown events.\n */\nconst handleMouseDown = () => {\n    // Store for click duration analysis.\n    const lastClick = eventStore.clicks[eventStore.clicks.length - 1];\n    if (lastClick && !lastClick.mousedownTime) {\n        lastClick.mousedownTime = Date.now();\n    }\n};\n\n/**\n * Handle mouseup events.\n */\nconst handleMouseUp = () => {\n    // Calculate click duration.\n    const lastClick = eventStore.clicks[eventStore.clicks.length - 1];\n    if (lastClick && lastClick.mousedownTime) {\n        lastClick.clickDuration = Date.now() - lastClick.mousedownTime;\n    }\n};\n\n/**\n * Handle mouseover events.\n *\n * @param {MouseEvent} e Mouse event.\n */\nconst handleMouseOver = (e) => {\n    addToStore('hovers', {\n        target: e.target,\n        timestamp: Date.now(),\n        type: 'over',\n    });\n};\n\n/**\n * Handle mouseout events.\n *\n * @param {MouseEvent} e Mouse event.\n */\nconst handleMouseOut = (e) => {\n    addToStore('hovers', {\n        target: e.target,\n        timestamp: Date.now(),\n        type: 'out',\n    });\n};\n\n/**\n * Handle keydown events.\n *\n * @param {KeyboardEvent} e Keyboard event.\n */\nconst handleKeyDown = (e) => {\n    const now = Date.now();\n    const lastKeystroke = eventStore.keystrokes[eventStore.keystrokes.length - 1];\n\n    addToStore('keystrokes', {\n        key: e.key.length === 1 ? 'char' : e.key, // Don't store actual characters for privacy.\n        timestamp: now,\n        deltaTime: lastKeystroke ? now - lastKeystroke.timestamp : 0,\n        type: 'down',\n    });\n};\n\n/**\n * Handle keyup events.\n */\nconst handleKeyUp = () => {\n    // Find matching keydown to calculate hold duration.\n    const keydowns = eventStore.keystrokes.filter(\n        (k) => k.type === 'down' && !k.holdDuration\n    );\n    const matchingKeydown = keydowns[keydowns.length - 1];\n    if (matchingKeydown) {\n        matchingKeydown.holdDuration = Date.now() - matchingKeydown.timestamp;\n    }\n};\n\n/**\n * Handle scroll events.\n */\nconst handleScroll = () => {\n    const now = Date.now();\n    const lastScroll = eventStore.scrolls[eventStore.scrolls.length - 1];\n\n    addToStore('scrolls', {\n        scrollY: window.scrollY,\n        scrollX: window.scrollX,\n        timestamp: now,\n        deltaTime: lastScroll ? now - lastScroll.timestamp : 0,\n        deltaY: lastScroll ? window.scrollY - lastScroll.scrollY : 0,\n        deltaX: lastScroll ? window.scrollX - lastScroll.scrollX : 0,\n    });\n};\n\n/**\n * Handle focus in events.\n *\n * @param {FocusEvent} e Focus event.\n */\nconst handleFocusIn = (e) => {\n    addToStore('focusChanges', {\n        target: {\n            tagName: e.target.tagName,\n            id: e.target.id,\n            type: e.target.type,\n        },\n        timestamp: Date.now(),\n        type: 'in',\n    });\n};\n\n/**\n * Handle focus out events.\n *\n * @param {FocusEvent} e Focus event.\n */\nconst handleFocusOut = (e) => {\n    addToStore('focusChanges', {\n        target: {\n            tagName: e.target.tagName,\n            id: e.target.id,\n            type: e.target.type,\n        },\n        timestamp: Date.now(),\n        type: 'out',\n    });\n};\n\n/**\n * Handle pointerdown events for CDP dispatch detection.\n *\n * @param {PointerEvent} e Pointer event.\n */\nconst handlePointerDown = (e) => {\n    addToStore('pointerEvents', {\n        type: 'down',\n        x: e.clientX,\n        y: e.clientY,\n        timestamp: Date.now(),\n        pointerType: e.pointerType,\n    });\n};\n\n/**\n * Handle pointermove events (throttled).\n *\n * @param {PointerEvent} e Pointer event.\n */\nconst handlePointerMove = (e) => {\n    const now = Date.now();\n    const last = eventStore.pointerEvents[eventStore.pointerEvents.length - 1];\n    if (last && now - last.timestamp < 50) {\n        return; // Throttle to 20Hz.\n    }\n    addToStore('pointerEvents', {\n        type: 'move',\n        x: e.clientX,\n        y: e.clientY,\n        timestamp: now,\n        pointerType: e.pointerType,\n    });\n};\n\n/**\n * Timestamp of last periodic save to sessionStorage.\n *\n * @type {number}\n */\nlet lastPeriodicSave = 0;\n\n/**\n * Add event to storage with size limiting.\n *\n * Also periodically saves to sessionStorage so that cross-page\n * accumulation works even when beforeunload does not fire\n * (e.g. CDP-driven page navigations by agents).\n *\n * @param {string} storeName Name of the store.\n * @param {Object} data Event data.\n */\nconst addToStore = (storeName, data) => {\n    eventStore[storeName].push(data);\n\n    // Limit store size.\n    if (eventStore[storeName].length > CONFIG.maxStoredEvents) {\n        eventStore[storeName].shift();\n    }\n\n    // Invalidate cache.\n    analysisCache = null;\n\n    // Periodic save: write to sessionStorage every 2 seconds at most.\n    // This ensures cross-page accumulation even if beforeunload doesn't fire.\n    const now = Date.now();\n    if (now - lastPeriodicSave > 2000) {\n        lastPeriodicSave = now;\n        try {\n            saveToSessionStorage();\n        } catch (e) {\n            // Ignore save errors.\n        }\n    }\n};\n\n/**\n * Check if there was a hover event before this click.\n *\n * @param {Element} target Click target.\n * @returns {boolean} True if hover preceded click.\n */\nconst checkPrecedingHover = (target) => {\n    const recentHovers = eventStore.hovers.slice(-20);\n    return recentHovers.some((h) => h.target === target && h.type === 'over');\n};\n\n/**\n * Check if there was mouse movement leading to click position.\n *\n * @param {number} x Click X coordinate.\n * @param {number} y Click Y coordinate.\n * @returns {boolean} True if mouse movement preceded click.\n */\nconst checkPrecedingMouseMove = (x, y) => {\n    const recentMoves = eventStore.mouseMoves.slice(-10);\n    if (recentMoves.length === 0) {\n        return false;\n    }\n\n    // Check if any recent movement was near the click position.\n    return recentMoves.some((m) => {\n        const distance = Math.sqrt((m.x - x) ** 2 + (m.y - y) ** 2);\n        return distance < 50;\n    });\n};\n\n/**\n * Analyze collected interaction data for anomalies.\n *\n * @returns {Object} Analysis results with anomaly signals.\n */\nexport const analyze = () => {\n    if (analysisCache) {\n        return analysisCache;\n    }\n\n    const results = {\n        timestamp: Date.now(),\n        duration: Date.now() - eventStore.startTime,\n        pageLoadCount: eventStore.pageLoadCount,\n        eventCounts: {\n            mouseMoves: eventStore.mouseMoves.length,\n            clicks: eventStore.clicks.length,\n            keystrokes: eventStore.keystrokes.length,\n            scrolls: eventStore.scrolls.length,\n            hovers: eventStore.hovers.length,\n            focusChanges: eventStore.focusChanges.length,\n            pointerEvents: eventStore.pointerEvents.length,\n        },\n        anomalies: [],\n        score: 0,\n    };\n\n    // Run individual analyses.\n    results.anomalies.push(...analyzeMouseMovement());\n    results.anomalies.push(...analyzeClicks());\n    results.anomalies.push(...analyzeKeystrokes());\n    results.anomalies.push(...analyzeScrolling());\n    results.anomalies.push(...analyzeEventSequence());\n\n    // Comet agentic mode analyses.\n    results.anomalies.push(...analyzeActionBursts());\n    results.anomalies.push(...analyzeCDPClickPatterns());\n    results.anomalies.push(...analyzePointerEvents());\n    results.anomalies.push(...analyzePerPageRatio());\n    results.anomalies.push(...analyzeScrollClickCorrelation());\n\n    // Calculate overall score.\n    results.score = calculateInteractionScore(results.anomalies);\n\n    analysisCache = results;\n    return results;\n};\n\n/**\n * Analyze mouse movement patterns.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzeMouseMovement = () => {\n    const anomalies = [];\n    const moves = eventStore.mouseMoves;\n\n    if (moves.length < CONFIG.minMouseMoves) {\n        anomalies.push({\n            name: 'mouse.insufficient_data',\n            value: moves.length,\n            weight: 2,\n        });\n        return anomalies;\n    }\n\n    // Check for perfectly linear movements.\n    // Note: humans trigger this at 0.44-0.57 so it's a weak signal.\n    const linearSegments = findLinearSegments(moves);\n    if (linearSegments > moves.length * 0.3) {\n        anomalies.push({\n            name: 'mouse.linear_movement',\n            value: linearSegments / moves.length,\n            weight: 3, // Reduced from 7 — humans trigger this often.\n        });\n    }\n\n    // Check for teleporting (instant position changes).\n    const teleports = moves.filter((m) => m.velocity > CONFIG.maxMouseSpeed);\n    if (teleports.length > 0) {\n        anomalies.push({\n            name: 'mouse.teleport',\n            value: teleports.length,\n            weight: 8,\n        });\n    }\n\n    // Check for no mouse movement at all (common in automated tests).\n    const duration = Date.now() - eventStore.startTime;\n    if (moves.length < duration / 5000) { // Less than 1 move per 5 seconds.\n        anomalies.push({\n            name: 'mouse.sparse_movement',\n            value: moves.length,\n            weight: 5,\n        });\n    }\n\n    // Check velocity variance (humans have high variance).\n    const velocities = moves.filter((m) => m.velocity).map((m) => m.velocity);\n    if (velocities.length > 5) {\n        const variance = calculateVariance(velocities);\n        if (variance < 0.1) {\n            anomalies.push({\n                name: 'mouse.constant_velocity',\n                value: variance,\n                weight: 6,\n            });\n        }\n    }\n\n    // KEY SIGNAL: Mouse-to-click ratio.\n    // Humans generate many mouse moves per click (typically 8-100+).\n    // CDP-driven agents generate almost no mouse moves (0-3 per click).\n    // Use clicks only — keystrokes don't require mouse movement, so including\n    // them inflates the denominator and penalises humans who type answers.\n    const totalClicks = eventStore.clicks.length;\n    if (totalClicks >= 3 && eventStore.pageLoadCount >= 2) {\n        const movePerClick = moves.length / totalClicks;\n        if (movePerClick < 2) {\n            // Almost no mouse movement relative to clicks — very strong agent signal.\n            anomalies.push({\n                name: 'comet.low_mouse_to_action_ratio',\n                value: movePerClick,\n                weight: 10,\n            });\n        } else if (movePerClick < 5) {\n            // Very low mouse movement — suspicious but not definitive.\n            anomalies.push({\n                name: 'comet.low_mouse_to_action_ratio',\n                value: movePerClick,\n                weight: 5,\n            });\n        }\n    }\n\n    return anomalies;\n};\n\n/**\n * Find linear segments in mouse movement.\n *\n * @param {Array} moves Mouse move events.\n * @returns {number} Count of linear segments.\n */\nconst findLinearSegments = (moves) => {\n    let linearCount = 0;\n    const threshold = 0.99; // Angle consistency threshold.\n\n    for (let i = 2; i < moves.length; i++) {\n        const angle1 = Math.atan2(\n            moves[i - 1].y - moves[i - 2].y,\n            moves[i - 1].x - moves[i - 2].x\n        );\n        const angle2 = Math.atan2(\n            moves[i].y - moves[i - 1].y,\n            moves[i].x - moves[i - 1].x\n        );\n\n        if (Math.abs(Math.cos(angle1 - angle2)) > threshold) {\n            linearCount++;\n        }\n    }\n\n    return linearCount;\n};\n\n/**\n * Analyze click patterns.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzeClicks = () => {\n    const anomalies = [];\n    const clicks = eventStore.clicks;\n\n    if (clicks.length < CONFIG.minClicks) {\n        return anomalies;\n    }\n\n    // Check for clicks at exact element centers (agents click perfectly).\n    const centerClicks = clicks.filter(\n        (c) => c.offsetFromCenter < CONFIG.centerClickTolerance\n    );\n    if (centerClicks.length > clicks.length * 0.5) {\n        anomalies.push({\n            name: 'click.center_precision',\n            value: centerClicks.length / clicks.length,\n            weight: 10, // Increased - strong agent indicator.\n        });\n    }\n\n    // Ultra-precise center clicks (< 2px offset) -- strong agentic indicator.\n    // Agents target elements by reference, landing at exact computed center.\n    const ultraPreciseClicks = clicks.filter(\n        (c) => c.offsetFromCenter < 2\n    );\n    if (ultraPreciseClicks.length > clicks.length * 0.6 && clicks.length >= 3) {\n        anomalies.push({\n            name: 'comet.ultra_precise_center',\n            value: ultraPreciseClicks.length / clicks.length,\n            weight: 10,\n        });\n    }\n\n    // Check for clicks without preceding hover.\n    const noHoverClicks = clicks.filter((c) => !c.hadPrecedingHover);\n    if (noHoverClicks.length > clicks.length * 0.7) {\n        anomalies.push({\n            name: 'click.no_hover',\n            value: noHoverClicks.length / clicks.length,\n            weight: 6,\n        });\n    }\n\n    // Check for clicks without preceding mouse movement (teleport clicks).\n    const noMoveClicks = clicks.filter((c) => !c.hadPrecedingMouseMove);\n    if (noMoveClicks.length > clicks.length * 0.5) {\n        anomalies.push({\n            name: 'click.no_movement',\n            value: noMoveClicks.length / clicks.length,\n            weight: 9, // Increased - agents teleport to click targets.\n        });\n    }\n\n    // STRONG INDICATOR: Clicks with NO mouse data at all (pure teleport).\n    const totalMouseMoves = eventStore.mouseMoves.length;\n    if (clicks.length >= 3 && totalMouseMoves < clicks.length * 2) {\n        anomalies.push({\n            name: 'click.teleport_pattern',\n            value: totalMouseMoves / clicks.length,\n            weight: 10, // Very strong - humans move mouse much more than they click.\n        });\n    }\n\n    // Check for impossibly fast clicks (< 50ms reaction time).\n    // Humans trigger this routinely with rapid double-clicks on radio buttons\n    // and \"Next page\" buttons during quizzes — weak signal on its own.\n    const interClickTimes = [];\n    for (let i = 1; i < clicks.length; i++) {\n        interClickTimes.push(clicks[i].timestamp - clicks[i - 1].timestamp);\n    }\n    const fastClicks = interClickTimes.filter((t) => t < CONFIG.minHumanReactionTime);\n    if (fastClicks.length > 0) {\n        anomalies.push({\n            name: 'click.superhuman_speed',\n            value: fastClicks.length,\n            weight: 3,\n        });\n    }\n\n    // Check for perfectly regular click timing.\n    if (interClickTimes.length >= 3) {\n        const variance = calculateVariance(interClickTimes);\n        if (variance < CONFIG.perfectTimingVariance) {\n            anomalies.push({\n                name: 'click.perfect_timing',\n                value: variance,\n                weight: 8,\n            });\n        }\n    }\n\n    return anomalies;\n};\n\n/**\n * Analyze keystroke patterns.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzeKeystrokes = () => {\n    const anomalies = [];\n    const keystrokes = eventStore.keystrokes.filter((k) => k.type === 'down');\n\n    // Zero keystrokes across multiple pages with significant click activity\n    // is a strong agent indicator. Humans press Tab, Space, Enter, arrow keys\n    // even on MCQ quizzes. Require 2+ pages to avoid penalising the first page load.\n    if (keystrokes.length === 0 && eventStore.clicks.length >= 5 && eventStore.pageLoadCount >= 2) {\n        anomalies.push({\n            name: 'comet.zero_keystrokes',\n            value: 0,\n            weight: 9,\n        });\n    }\n\n    if (keystrokes.length < CONFIG.minKeystrokes) {\n        return anomalies;\n    }\n\n    // Check inter-key timing variance.\n    const interKeyTimes = keystrokes.slice(1).map((k) => k.deltaTime);\n    if (interKeyTimes.length >= 5) {\n        const variance = calculateVariance(interKeyTimes);\n        if (variance < CONFIG.perfectTimingVariance) {\n            anomalies.push({\n                name: 'keystroke.perfect_timing',\n                value: variance,\n                weight: 9,\n            });\n        }\n    }\n\n    // Comet-specific: check coefficient of variation for inter-key timing.\n    // Human typing has CV > 0.3; agent-dispatched keystrokes have CV < 0.1.\n    const keyMean = interKeyTimes.reduce((a, b) => a + b, 0) / interKeyTimes.length;\n    const keyStdDev = Math.sqrt(calculateVariance(interKeyTimes));\n    const keyCV = keyMean > 0 ? keyStdDev / keyMean : 0;\n\n    if (keyCV < 0.1 && interKeyTimes.length >= 10) {\n        anomalies.push({\n            name: 'comet.uniform_keystroke_cadence',\n            value: keyCV,\n            weight: 9,\n        });\n    }\n\n    // Check for impossibly fast typing (< 30ms between keys is ~2000 WPM).\n    const fastKeys = interKeyTimes.filter((t) => t > 0 && t < 30);\n    if (fastKeys.length > interKeyTimes.length * 0.3) {\n        anomalies.push({\n            name: 'keystroke.superhuman_speed',\n            value: fastKeys.length / interKeyTimes.length,\n            weight: 9,\n        });\n    }\n\n    // Check key hold duration variance.\n    const holdDurations = keystrokes.filter((k) => k.holdDuration).map((k) => k.holdDuration);\n    if (holdDurations.length >= 5) {\n        const variance = calculateVariance(holdDurations);\n        if (variance < 1) {\n            anomalies.push({\n                name: 'keystroke.constant_hold',\n                value: variance,\n                weight: 7,\n            });\n        }\n\n        // Comet-specific: check hold duration coefficient of variation.\n        if (holdDurations.length >= 10) {\n            const holdMean = holdDurations.reduce((a, b) => a + b, 0) / holdDurations.length;\n            const holdStdDev = Math.sqrt(calculateVariance(holdDurations));\n            const holdCV = holdMean > 0 ? holdStdDev / holdMean : 0;\n\n            if (holdCV < 0.1) {\n                anomalies.push({\n                    name: 'comet.uniform_hold_duration',\n                    value: holdCV,\n                    weight: 8,\n                });\n            }\n        }\n    }\n\n    return anomalies;\n};\n\n/**\n * Analyze scrolling patterns.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzeScrolling = () => {\n    const anomalies = [];\n    const scrolls = eventStore.scrolls;\n\n    if (scrolls.length < 3) {\n        return anomalies;\n    }\n\n    // Check for instant scroll jumps (no smooth scrolling).\n    const instantScrolls = scrolls.filter((s) => s.deltaTime < 10 && Math.abs(s.deltaY) > 100);\n    if (instantScrolls.length > scrolls.length * 0.5) {\n        anomalies.push({\n            name: 'scroll.instant_jump',\n            value: instantScrolls.length / scrolls.length,\n            weight: 6,\n        });\n    }\n\n    // Check for perfectly regular scroll amounts.\n    const scrollAmounts = scrolls.map((s) => Math.abs(s.deltaY)).filter((v) => v > 0);\n    if (scrollAmounts.length >= 3) {\n        const variance = calculateVariance(scrollAmounts);\n        if (variance < 1) {\n            anomalies.push({\n                name: 'scroll.constant_amount',\n                value: variance,\n                weight: 5,\n            });\n        }\n    }\n\n    return anomalies;\n};\n\n/**\n * Analyze event sequence patterns.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzeEventSequence = () => {\n    const anomalies = [];\n\n    // Check for missing event sequences (e.g., click without mousedown).\n    // Automated tools sometimes skip intermediate events.\n\n    // Check ratio of hovers to clicks (humans hover a lot before clicking).\n    const hoverRatio = eventStore.hovers.length / Math.max(eventStore.clicks.length, 1);\n    if (hoverRatio < 2 && eventStore.clicks.length >= CONFIG.minClicks) {\n        anomalies.push({\n            name: 'sequence.low_hover_ratio',\n            value: hoverRatio,\n            weight: 5,\n        });\n    }\n\n    // Check for focus changes without preceding clicks or tabs.\n    // Direct focus (via JS) is common in automation.\n    const directFocus = eventStore.focusChanges.filter((f) => {\n        // Check if there was a recent click or keystroke.\n        const recentEvents = [\n            ...eventStore.clicks.slice(-5),\n            ...eventStore.keystrokes.slice(-5),\n        ];\n        const hasRecentInteraction = recentEvents.some(\n            (e) => Math.abs(e.timestamp - f.timestamp) < 100\n        );\n        return !hasRecentInteraction;\n    });\n\n    if (directFocus.length > eventStore.focusChanges.length * 0.5 &&\n        eventStore.focusChanges.length >= 3) {\n        anomalies.push({\n            name: 'sequence.direct_focus',\n            value: directFocus.length / eventStore.focusChanges.length,\n            weight: 3,\n        });\n    }\n\n    // Rapid sequential focus changes across different form fields.\n    // Agents navigate fields programmatically, producing near-instant focus changes.\n    const focusIns = eventStore.focusChanges.filter((f) => f.type === 'in');\n    if (focusIns.length >= 3) {\n        let rapidSequentialFocus = 0;\n        for (let j = 1; j < focusIns.length; j++) {\n            const gap = focusIns[j].timestamp - focusIns[j - 1].timestamp;\n            const differentTarget = focusIns[j].target.id !== focusIns[j - 1].target.id;\n            if (gap < 200 && differentTarget) {\n                rapidSequentialFocus++;\n            }\n        }\n        if (rapidSequentialFocus >= 4) {\n            anomalies.push({\n                name: 'comet.rapid_focus_sequence',\n                value: rapidSequentialFocus,\n                weight: 5,\n            });\n        }\n    }\n\n    return anomalies;\n};\n\n/**\n * Calculate variance of an array of numbers.\n *\n * @param {Array<number>} arr Array of numbers.\n * @returns {number} Variance.\n */\nconst calculateVariance = (arr) => {\n    if (arr.length < 2) {\n        return 0;\n    }\n    const mean = arr.reduce((a, b) => a + b, 0) / arr.length;\n    const squareDiffs = arr.map((value) => Math.pow(value - mean, 2));\n    return squareDiffs.reduce((a, b) => a + b, 0) / arr.length;\n};\n\n/**\n * Calculate overall interaction score.\n *\n * Applies a confidence discount when total events are low, to avoid\n * false positives from sparse data (e.g. a single quiz page with 2 clicks).\n *\n * @param {Array} anomalies Detected anomalies.\n * @returns {number} Score from 0-100.\n */\nconst calculateInteractionScore = (anomalies) => {\n    if (anomalies.length === 0) {\n        return 0;\n    }\n\n    const totalWeight = anomalies.reduce((sum, a) => sum + (a.weight || 0), 0);\n    const maxPossibleWeight = anomalies.length * 10;\n\n    // Check for \"smoking gun\" combinations that indicate definite agent.\n    // Only physically-impossible signals qualify — temporal/behavioral signals\n    // (action_burst, read_then_act, no_mousemove_trail) fire for human quiz-takers.\n    const hasCenterPrecision = anomalies.some((a) => a.name === 'click.center_precision');\n    const hasTeleport = anomalies.some((a) => a.name === 'click.teleport_pattern');\n    const hasNoMovement = anomalies.some((a) => a.name === 'click.no_movement');\n    const hasUltraPrecise = anomalies.some((a) => a.name === 'comet.ultra_precise_center');\n    // Only the extreme variant (movePerAction < 2, weight 10) is physically impossible.\n    const hasLowMouseRatio = anomalies.some(\n        (a) => a.name === 'comet.low_mouse_to_action_ratio' && a.weight >= 10\n    );\n    const hasZeroKeystrokes = anomalies.some((a) => a.name === 'comet.zero_keystrokes');\n    const hasLowPerPageRatio = anomalies.some((a) => a.name === 'comet.low_per_page_mouse_ratio');\n\n    // Multiple strong signals = high confidence agent.\n    let multiplier = 1.0;\n    const strongSignals = [\n        hasCenterPrecision, hasTeleport, hasNoMovement,\n        hasUltraPrecise, hasLowMouseRatio,\n        hasZeroKeystrokes, hasLowPerPageRatio,\n    ].filter(Boolean).length;\n    if (strongSignals >= 3) {\n        multiplier = 1.5; // 3+ strong signals = very likely agent.\n    } else if (strongSignals >= 2) {\n        multiplier = 1.25; // 2 strong signals = boost score.\n    }\n\n    // Normalize and apply scaling.\n    let rawScore = (totalWeight / Math.max(maxPossibleWeight, 30)) * 100 * multiplier;\n\n    // Confidence discount: with very few events, ratios are unreliable.\n    // A human clicking 3 times with 2 mouse moves looks identical to an agent.\n    // Require more data before giving high scores.\n    const totalActions = eventStore.clicks.length + eventStore.keystrokes.length;\n    const totalMoves = eventStore.mouseMoves.length;\n    const totalEvents = totalActions + totalMoves;\n\n    if (totalEvents < 10) {\n        // Very sparse — heavily discount unless smoking-gun signals present.\n        // Center_precision, ultra_precise_center, zero keystrokes are reliable even with few events.\n        const hasReliableSignal = hasCenterPrecision || hasUltraPrecise || hasLowMouseRatio\n            || hasZeroKeystrokes || hasLowPerPageRatio;\n        if (!hasReliableSignal) {\n            rawScore *= 0.3; // 70% discount for ratio-only signals with sparse data.\n        } else {\n            rawScore *= 0.7; // 30% discount even with reliable signals if data is sparse.\n        }\n    } else if (totalEvents < 25) {\n        // Moderate data — small discount.\n        rawScore *= 0.85;\n    }\n    // 25+ events = full confidence, no discount.\n\n    return Math.min(100, Math.round(rawScore));\n};\n\n/**\n * Analyze action bursts — rapid sequences of heterogeneous events\n * preceded by a quiescent period. Characteristic of agentic AI\n * that reads the DOM, pauses to \"think\", then executes rapidly.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzeActionBursts = () => {\n    const anomalies = [];\n\n    // Merge all action events into a sorted timeline.\n    const allActions = [\n        ...eventStore.clicks.map((e) => ({timestamp: e.timestamp, actionType: 'click'})),\n        ...eventStore.keystrokes.filter((k) => k.type === 'down').map((e) => ({timestamp: e.timestamp, actionType: 'keystroke'})),\n        ...eventStore.focusChanges.map((e) => ({timestamp: e.timestamp, actionType: 'focus'})),\n    ].sort((a, b) => a.timestamp - b.timestamp);\n\n    if (allActions.length < 5) {\n        return anomalies;\n    }\n\n    let burstCount = 0;\n    let readThenActCount = 0;\n    let i = 0;\n\n    while (i < allActions.length) {\n        // Find all actions within 2000ms of this one.\n        let windowEnd = i;\n        while (windowEnd < allActions.length &&\n               allActions[windowEnd].timestamp - allActions[i].timestamp < 2000) {\n            windowEnd++;\n        }\n        const burstSize = windowEnd - i;\n        const actionTypes = new Set(\n            allActions.slice(i, windowEnd).map((a) => a.actionType)\n        );\n\n        if (burstSize >= 5 && actionTypes.size >= 2) {\n            burstCount++;\n\n            // Check for preceding quiescent period (3+ seconds gap).\n            if (i > 0) {\n                const gap = allActions[i].timestamp - allActions[i - 1].timestamp;\n                if (gap >= 3000) {\n                    readThenActCount++;\n                }\n            }\n            // Skip past this burst to avoid double-counting.\n            i = windowEnd;\n        } else {\n            i++;\n        }\n    }\n\n    // Normalize by page count — answering one question per page naturally\n    // produces ~1-2 bursts and ~1 read-then-act per page.\n    // Only flag when the per-page rate exceeds normal quiz-taking.\n    const pages = Math.max(eventStore.pageLoadCount, 1);\n    const burstsPerPage = burstCount / pages;\n    const readActPerPage = readThenActCount / pages;\n\n    if (burstsPerPage >= 3) {\n        anomalies.push({\n            name: 'comet.action_burst',\n            value: burstCount,\n            weight: 5,\n        });\n    }\n\n    if (readActPerPage >= 2) {\n        anomalies.push({\n            name: 'comet.read_then_act',\n            value: readThenActCount,\n            weight: 5,\n        });\n    }\n\n    return anomalies;\n};\n\n/**\n * Analyze CDP-dispatched click patterns.\n * CDP-dispatched clicks via Input.dispatchMouseEvent lack the natural\n * mousemove trail that precedes a human click.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzeCDPClickPatterns = () => {\n    const anomalies = [];\n    const clicks = eventStore.clicks;\n    const moves = eventStore.mouseMoves;\n\n    if (clicks.length < 3) {\n        return anomalies;\n    }\n\n    // Guard against cross-page stale data: find the latest mousemove timestamp.\n    const latestMoveTime = moves.length > 0 ? moves[moves.length - 1].timestamp : 0;\n\n    // For each click, count mousemoves in the 300ms window before it.\n    // Skip clicks that are stale (> 30s before the latest mousemove) to avoid\n    // cross-page accumulation artifacts.\n    let zeroTrailClicks = 0;\n    let validClicks = 0;\n\n    for (const click of clicks) {\n        if (latestMoveTime > 0 && click.timestamp < latestMoveTime - 30000) {\n            continue; // Stale cross-page click — skip.\n        }\n        validClicks++;\n        const precedingMoves = moves.filter((m) =>\n            m.timestamp > click.timestamp - 300 &&\n            m.timestamp < click.timestamp\n        );\n        if (precedingMoves.length === 0) {\n            zeroTrailClicks++;\n        }\n    }\n\n    if (validClicks < 3) {\n        return anomalies;\n    }\n\n    const ratio = zeroTrailClicks / validClicks;\n    if (ratio > 0.85) {\n        anomalies.push({\n            name: 'comet.no_mousemove_trail',\n            value: ratio,\n            weight: 6,\n        });\n    }\n\n    return anomalies;\n};\n\n/**\n * Analyze pointer events relative to mouse clicks.\n * Human interactions generate both pointer and mouse events.\n * CDP-dispatched mouse events may lack corresponding pointer events.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzePointerEvents = () => {\n    const anomalies = [];\n    const clicks = eventStore.clicks;\n    const pointerDowns = eventStore.pointerEvents.filter((p) => p.type === 'down');\n\n    if (clicks.length < 3) {\n        return anomalies;\n    }\n\n    const ratio = pointerDowns.length / clicks.length;\n    if (ratio < 0.3) {\n        anomalies.push({\n            name: 'comet.missing_pointer_events',\n            value: ratio,\n            weight: 4,\n        });\n    }\n\n    return anomalies;\n};\n\n/**\n * Analyze per-page mouse-to-click ratios.\n *\n * Cross-page accumulation can mask an agent's low per-page mouse activity.\n * An agent generating 0-3 mousemoves per page accumulates 200+ across 10 pages,\n * making the aggregate ratio look human-like. Per-page analysis catches this.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzePerPageRatio = () => {\n    const anomalies = [];\n\n    // Build stats array: prior pages from perPageStats + current page computed live.\n    const pageStart = eventStore.pageStartTime;\n    const currentPageMoves = eventStore.mouseMoves.filter((m) => m.timestamp >= pageStart).length;\n    const currentPageClicks = eventStore.clicks.filter((c) => c.timestamp >= pageStart).length;\n    const allPageStats = [\n        ...eventStore.perPageStats,\n        {moves: currentPageMoves, clicks: currentPageClicks},\n    ];\n\n    // Need at least 3 pages with click activity to be meaningful.\n    const pagesWithClicks = allPageStats.filter((p) => p.clicks >= 1);\n    if (pagesWithClicks.length < 3) {\n        return anomalies;\n    }\n\n    // Count pages where the mouse-to-click ratio is agent-like (< 3 moves per click).\n    const lowRatioPages = pagesWithClicks.filter((p) => p.moves / p.clicks < 3).length;\n    const lowRatioFraction = lowRatioPages / pagesWithClicks.length;\n\n    if (lowRatioFraction >= 0.7) {\n        anomalies.push({\n            name: 'comet.low_per_page_mouse_ratio',\n            value: lowRatioFraction,\n            weight: 10,\n        });\n    }\n\n    return anomalies;\n};\n\n/**\n * Analyze scroll-then-click correlation.\n *\n * Agents use scrollIntoView() before each click, producing a consistent\n * pattern of scroll event immediately followed by click. Humans scroll\n * to read content and click sporadically — the scroll-click pairing is\n * much less consistent.\n *\n * @returns {Array} Anomaly signals.\n */\nconst analyzeScrollClickCorrelation = () => {\n    const anomalies = [];\n    const clicks = eventStore.clicks;\n    const scrolls = eventStore.scrolls;\n\n    if (clicks.length < 5 || scrolls.length < 5) {\n        return anomalies;\n    }\n\n    // For each click, check if a scroll occurred within 500ms before it.\n    let scrollPrecededClicks = 0;\n\n    for (const click of clicks) {\n        const hasRecentScroll = scrolls.some((s) =>\n            s.timestamp > click.timestamp - 500 &&\n            s.timestamp < click.timestamp\n        );\n        if (hasRecentScroll) {\n            scrollPrecededClicks++;\n        }\n    }\n\n    const ratio = scrollPrecededClicks / clicks.length;\n    if (ratio >= 0.7) {\n        anomalies.push({\n            name: 'comet.scroll_then_click',\n            value: ratio,\n            weight: 8,\n        });\n    }\n\n    return anomalies;\n};\n\n/**\n * Get the sessionStorage key for cross-page event accumulation.\n *\n * @returns {string} Storage key scoped by context.\n */\nconst getStorageKey = () => {\n    return contextId ? `agentdetect_events_${contextId}` : 'agentdetect_events';\n};\n\n/**\n * Load accumulated events from sessionStorage (prior pages in same session).\n *\n * @returns {void}\n */\nconst loadFromSessionStorage = () => {\n    try {\n        const stored = sessionStorage.getItem(getStorageKey());\n        if (!stored) {\n            return;\n        }\n        const data = JSON.parse(stored);\n\n        // Restore startTime from the original first page.\n        if (data.startTime) {\n            eventStore.startTime = data.startTime;\n        }\n\n        // Restore page load count and increment.\n        eventStore.pageLoadCount = (data.pageLoadCount || 1) + 1;\n\n        // Merge stored events — keep the most recent ones within limits.\n        const storeNames = ['mouseMoves', 'clicks', 'keystrokes', 'scrolls', 'focusChanges', 'pointerEvents'];\n        for (const name of storeNames) {\n            if (data[name] && Array.isArray(data[name])) {\n                // Prepend prior events, then trim to max.\n                eventStore[name] = [...data[name], ...eventStore[name]];\n                if (eventStore[name].length > CONFIG.maxStoredEvents) {\n                    eventStore[name] = eventStore[name].slice(-CONFIG.maxStoredEvents);\n                }\n            }\n        }\n\n        // Don't restore hovers — they hold element references which can't be serialised.\n\n        // Restore per-page statistics from prior pages.\n        if (data.perPageStats && Array.isArray(data.perPageStats)) {\n            eventStore.perPageStats = data.perPageStats;\n        }\n\n        // Invalidate analysis cache since we loaded new data.\n        analysisCache = null;\n    } catch (e) {\n        // SessionStorage unavailable or data corrupt — start fresh.\n    }\n};\n\n/**\n * Save current events to sessionStorage for the next page load.\n * Called on beforeunload to persist cross-page.\n *\n * @returns {void}\n */\nexport const saveToSessionStorage = () => {\n    try {\n        // Compute current-page stats before saving.\n        const pageStart = eventStore.pageStartTime;\n        const currentPageMoves = eventStore.mouseMoves.filter((m) => m.timestamp >= pageStart).length;\n        const currentPageClicks = eventStore.clicks.filter((c) => c.timestamp >= pageStart).length;\n        const currentPageKeys = eventStore.keystrokes.filter((k) => k.timestamp >= pageStart).length;\n        const currentPageScrolls = eventStore.scrolls.filter((s) => s.timestamp >= pageStart).length;\n        const updatedPerPageStats = [\n            ...eventStore.perPageStats,\n            {moves: currentPageMoves, clicks: currentPageClicks, keys: currentPageKeys, scrolls: currentPageScrolls},\n        ].slice(-20); // Keep last 20 pages.\n\n        // Save a compressed version — most recent 200 per type, no DOM references.\n        const data = {\n            startTime: eventStore.startTime,\n            pageLoadCount: eventStore.pageLoadCount,\n            perPageStats: updatedPerPageStats,\n            mouseMoves: eventStore.mouseMoves.slice(-200),\n            clicks: eventStore.clicks.slice(-200).map((c) => ({\n                x: c.x,\n                y: c.y,\n                timestamp: c.timestamp,\n                offsetFromCenter: c.offsetFromCenter,\n                hadPrecedingHover: c.hadPrecedingHover,\n                hadPrecedingMouseMove: c.hadPrecedingMouseMove,\n                clickDuration: c.clickDuration,\n            })),\n            keystrokes: eventStore.keystrokes.slice(-200).map((k) => ({\n                key: k.key,\n                timestamp: k.timestamp,\n                deltaTime: k.deltaTime,\n                type: k.type,\n                holdDuration: k.holdDuration,\n            })),\n            scrolls: eventStore.scrolls.slice(-200),\n            focusChanges: eventStore.focusChanges.slice(-200).map((f) => ({\n                target: f.target,\n                timestamp: f.timestamp,\n                type: f.type,\n            })),\n            // Prioritize pointer downs over pointer moves to prevent ratio deflation.\n            pointerEvents: (() => {\n                const downs = eventStore.pointerEvents.filter((p) => p.type === 'down').slice(-200);\n                const remaining = 200 - downs.length;\n                const moves = remaining > 0\n                    ? eventStore.pointerEvents.filter((p) => p.type !== 'down').slice(-remaining)\n                    : [];\n                return [...downs, ...moves].sort((a, b) => a.timestamp - b.timestamp);\n            })(),\n        };\n        sessionStorage.setItem(getStorageKey(), JSON.stringify(data));\n    } catch (e) {\n        // Ignore storage errors (quota exceeded, etc.).\n    }\n};\n\n/**\n * Get raw event data for debugging/inspection.\n *\n * @returns {Object} Event store data.\n */\nexport const getRawData = () => {\n    return {\n        ...eventStore,\n        isMonitoring,\n    };\n};\n\n/**\n * Reset all collected data.\n *\n * @returns {void}\n */\nexport const reset = () => {\n    eventStore.mouseMoves = [];\n    eventStore.clicks = [];\n    eventStore.keystrokes = [];\n    eventStore.scrolls = [];\n    eventStore.hovers = [];\n    eventStore.focusChanges = [];\n    eventStore.pointerEvents = [];\n    eventStore.startTime = Date.now();\n    eventStore.pageStartTime = Date.now();\n    eventStore.pageLoadCount = 1;\n    eventStore.perPageStats = [];\n    analysisCache = null;\n};\n\nexport default {\n    startMonitoring,\n    stopMonitoring,\n    analyze,\n    getRawData,\n    reset,\n    saveToSessionStorage,\n    CONFIG,\n};\n"],"names":["CONFIG","minMouseMoves","minClicks","minKeystrokes","perfectTimingVariance","minHumanReactionTime","maxMouseSpeed","centerClickTolerance","maxStoredEvents","analysisInterval","eventStore","mouseMoves","clicks","keystrokes","scrolls","hovers","focusChanges","pointerEvents","startTime","Date","now","pageLoadCount","pageStartTime","perPageStats","contextId","analysisCache","isMonitoring","startMonitoring","options","loadFromSessionStorage","document","addEventListener","handleMouseMove","passive","handleClick","capture","handleMouseDown","handleMouseUp","handleMouseOver","handleMouseOut","handleKeyDown","handleKeyUp","handleScroll","window","handleFocusIn","handleFocusOut","handlePointerDown","handlePointerMove","stopMonitoring","removeEventListener","e","lastMove","length","moveData","x","clientX","y","clientY","timestamp","deltaTime","deltaX","deltaY","distance","Math","sqrt","velocity","addToStore","target","rect","getBoundingClientRect","elementCenterX","left","width","elementCenterY","top","height","offsetFromCenter","clickData","tagName","id","className","hadPrecedingHover","checkPrecedingHover","hadPrecedingMouseMove","checkPrecedingMouseMove","lastClick","mousedownTime","clickDuration","type","lastKeystroke","key","keydowns","filter","k","holdDuration","matchingKeydown","lastScroll","scrollY","scrollX","pointerType","last","lastPeriodicSave","storeName","data","push","shift","saveToSessionStorage","slice","some","h","recentMoves","m","analyze","results","duration","eventCounts","anomalies","score","analyzeMouseMovement","analyzeClicks","analyzeKeystrokes","analyzeScrolling","analyzeEventSequence","analyzeActionBursts","analyzeCDPClickPatterns","analyzePointerEvents","analyzePerPageRatio","analyzeScrollClickCorrelation","calculateInteractionScore","moves","name","value","weight","linearSegments","findLinearSegments","teleports","velocities","map","variance","calculateVariance","totalClicks","movePerClick","linearCount","i","angle1","atan2","angle2","abs","cos","centerClicks","c","ultraPreciseClicks","noHoverClicks","noMoveClicks","totalMouseMoves","interClickTimes","fastClicks","t","interKeyTimes","keyMean","reduce","a","b","keyStdDev","keyCV","fastKeys","holdDurations","holdMean","holdStdDev","holdCV","instantScrolls","s","scrollAmounts","v","hoverRatio","max","directFocus","f","focusIns","rapidSequentialFocus","j","gap","differentTarget","arr","mean","pow","totalWeight","sum","maxPossibleWeight","hasCenterPrecision","hasTeleport","hasNoMovement","hasUltraPrecise","hasLowMouseRatio","hasZeroKeystrokes","hasLowPerPageRatio","multiplier","strongSignals","Boolean","rawScore","totalEvents","min","round","allActions","actionType","sort","burstCount","readThenActCount","windowEnd","burstSize","actionTypes","Set","size","pages","readActPerPage","latestMoveTime","zeroTrailClicks","validClicks","click","ratio","pointerDowns","p","pageStart","currentPageMoves","currentPageClicks","pagesWithClicks","lowRatioFraction","scrollPrecededClicks","getStorageKey","stored","sessionStorage","getItem","JSON","parse","storeNames","Array","isArray","currentPageKeys","currentPageScrolls","updatedPerPageStats","keys","downs","remaining","setItem","stringify","getRawData","reset"],"mappings":"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"}